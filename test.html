<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Map Explorer (Vanilla)</title>

    <!-- Mapbox GL JS CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet" />

    <style>
      /******************************************************************
       * [GLOBAL RESET / BASE]
       ******************************************************************/
      * { box-sizing: border-box; }
      body {
        margin: 0;
        background: #000;
        color: #fff;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      /******************************************************************
       * [THEME: LIGHT MODE]
       * - body에 .light 클래스가 붙으면 라이트 테마로 전환
       * - 전체 배경/텍스트/사이드바/컨트롤/팝업 등 테마별 스타일링
       ******************************************************************/
      body.light { background: #f3f4f6; color: #0f172a; }
      body.light .app { background: #f3f4f6; }
      body.light .sidebar { background: #fff; border-right: 1px solid #e2e8f0; }
      body.light .sidebar-header { background: #fff; border-bottom: 1px solid #e2e8f0; }
      body.light .controls { border-bottom: 1px solid #e2e8f0; }
      body.light input[type="text"], body.light select { background: #fff; color: #0f172a; border: 1px solid #cbd5e1; }
      body.light button { background: #e2e8f0; color: #0f172a; border: 1px solid #cbd5e1; }
      body.light .status-box { background: #e2e8f0; }
      body.light .photo-item { background: #fff; border: 1px solid #e2e8f0; }
      body.light .photo-item.active { background: rgba(59,130,246,.12); border: 1px solid rgba(59,130,246,.35); }
      body.light #timeline-bar { background: rgba(255,255,255,.85); border: 1px solid rgba(15,23,42,.10); }

      /******************************************************************
       * [LAYOUT]
       * - 전체 화면을 flex로 분할
       * - left: sidebar / right: map
       ******************************************************************/
      .app { height: 100vh; width: 100vw; display: flex; background: #000; }
      .sidebar { width: 340px; display: flex; flex-direction: column; background: #111; border-right: 1px solid #333; }

      /******************************************************************
       * [SIDEBAR HEADER]
       ******************************************************************/
      .sidebar-header {
        padding: 12px;
        background: #181818;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .sidebar-header h2 { margin: 0; font-size: 1.1rem; }

      /******************************************************************
       * [CONTROLS]
       ******************************************************************/
      .controls { padding: 12px; border-bottom: 1px solid #333; display: flex; flex-direction: column; gap: 10px; }
      input[type="text"], select { padding: 8px 12px; border-radius: 6px; border: 1px solid #555; background: #0b0b0b; color: #fff; }
      button { padding: 8px 12px; border-radius: 6px; border: 1px solid #6a6a6a; background: #333; color: #fff; cursor: pointer; }
      button:disabled { background: #555; cursor: not-allowed; }

      .status-box { background: #222; border-radius: 4px; padding: 8px; font-size: .8rem; min-height: 3em; }
      .photo-list { flex: 1; overflow-y: auto; padding: 8px; }

      /******************************************************************
       * [PHOTO LIST ITEM]
       * - 썸네일 + 파일명
       * - active 상태는 목록 선택 강조
       ******************************************************************/
      .photo-item { display: flex; gap: 10px; align-items: center; padding: 6px 8px; margin-bottom: 6px; border-radius: 6px; cursor: pointer; background: #141414; border: 1px solid #202020; }
      .photo-item.active { background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.08); }

      /******************************************************************
       * [THUMB WRAP + THUMB LOADING SPINNER]
       * - 이미지 로딩이 늦을 때 spinner를 띄워 UX 개선
       * - loaded 클래스가 붙으면 spinner 숨김
       ******************************************************************/
      .thumb-wrap { position: relative; width: 60px; height: 60px; flex: 0 0 60px; }
      .thumb-wrap img { width: 60px; height: 60px; object-fit: cover; border-radius: 4px; display: block; }
      .thumb-wrap .thumb-spinner { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
      .thumb-wrap.loaded .thumb-spinner { display:none; }

      /******************************************************************
       * [MAP CONTAINER]
       ******************************************************************/
      .map-wrap { flex: 1; position: relative; }
      #map { position: absolute; inset: 0; }

      /******************************************************************
       * [MAP LOADING OVERLAY]
       * - Mapbox style 변경/초기 로딩 시 가림막 + spinner
       ******************************************************************/
      #map-loading {
        position: absolute; inset: 0;
        background: rgba(0,0,0,.5);
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        z-index: 10;
        font-weight: 600;
        transition: opacity .25s ease;
        gap: 12px;
      }
      #map-loading.hide { opacity: 0; pointer-events: none; }

      /******************************************************************
       * [THEME BUTTON]
       ******************************************************************/
      #btnTheme { font-size: .7rem; padding: 4px 8px; border-radius: 9999px; }

      /******************************************************************
       * [TIMELINE BAR]
       * - 상단 중앙 고정. range 슬라이더로 월 단위 필터 적용.
       ******************************************************************/
      #timeline-bar {
        position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
        width: min(720px, 90vw);
        background: rgba(0,0,0,.45); backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,.15); border-radius: 9999px;
        padding: 8px 16px 12px; z-index: 20;
      }
      #timeline-range { width: 100%; }
      #timeline-label { margin-top: 4px; font-size: .75rem; text-align: center; opacity: .75; }

      /******************************************************************
       * [MAPBOX POPUP THEME]
       * - Mapbox 기본 팝업 스타일을 프로젝트 UI 톤에 맞게 오버라이드
       ******************************************************************/
      .mapboxgl-popup-content { background: #111 !important; border: 1px solid #333 !important; color: #fff !important; border-radius: 16px !important; padding: 10px !important; }
      .mapboxgl-popup-tip { border-top-color: #111 !important; }
      body.light .mapboxgl-popup-content { background: #ffffff !important; border: 1px solid rgba(15,23,42,.12) !important; color: #0f172a !important; }
      body.light .mapboxgl-popup-tip { border-top-color: #ffffff !important; }
      .mapboxgl-popup-content img { display: block; border-radius: 10px; background: #0f172a; }
      body.light .mapboxgl-popup-content img { background: #ffffff; }

      /******************************************************************
       * [DENSITY UI - REGION CONTROLS + LEGEND]
       * - density 모드에서만 보여주는 UI
       ******************************************************************/
      #region-controls { position: absolute; z-index: 25; top: 12px; left: 12px; background: #111a; border: 1px solid #333; padding: 10px; border-radius: 12px; color: #fff; width: 200px; backdrop-filter: blur(6px); }
      #density-legend { position: absolute; z-index: 25; bottom: 12px; left: 12px; background: #111a; border: 1px solid #333; padding: 10px; border-radius: 12px; color: #fff; min-width: 180px; backdrop-filter: blur(6px); }
      body.light #region-controls, body.light #density-legend { background:#fff; border:1px solid #e2e8f0; color:#0f172a; }
      #density-legend { cursor: pointer; user-select: none; }

      /******************************************************************
       * [DENSITY PALETTE POP]
       * - 범례 클릭 시 열리는 팔레트 선택 팝업
       ******************************************************************/
      #density-palette-pop{
        position: absolute;
        z-index: 26;
        left: 12px;
        bottom: 92px;
        width: 210px;
        background: rgba(17,17,17,.92);
        border: 1px solid rgba(255,255,255,.14);
        border-radius: 14px;
        padding: 10px;
        backdrop-filter: blur(8px);
        box-shadow: 0 10px 30px rgba(0,0,0,.35);
        display: none;
      }
      body.light #density-palette-pop{
        background: rgba(255,255,255,.95);
        border: 1px solid rgba(15,23,42,.12);
        color: #0f172a;
      }
      #density-palette-pop .pop-title{
        font-weight: 700;
        margin-bottom: 8px;
        font-size: 13px;
      }
      #density-palette-pop .pop-grid{
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      #density-palette-pop .pop-opt{
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,.12);
        background: rgba(255,255,255,.06);
        color: inherit;
        cursor: pointer;
        font-size: 13px;
      }
      body.light #density-palette-pop .pop-opt{
        border: 1px solid rgba(15,23,42,.12);
        background: rgba(15,23,42,.04);
      }
      #density-palette-pop .pop-opt:hover{ transform: translateY(-1px); }
      #density-palette-pop .pop-opt.active{ outline: 2px solid rgba(96,165,250,.85); }
      #density-palette-pop .swatch{
        width: 16px; height: 16px;
        border-radius: 6px;
        border: 1px solid rgba(255,255,255,.14);
        display: inline-block;
      }
      #density-palette-pop .swatch[data-pal="blue"]   { background: #3b82f6; }
      #density-palette-pop .swatch[data-pal="red"]    { background: #ef4444; }
      #density-palette-pop .swatch[data-pal="orange"] { background: #f97316; }
      #density-palette-pop .swatch[data-pal="yellow"] { background: #eab308; }
      #density-palette-pop .pop-hint{
        margin-top: 8px;
        font-size: 11px;
        opacity: .75;
        line-height: 1.3;
      }

      /******************************************************************
       * [MODE SWITCH]
       * - Basic / Glow / Density 버튼
       ******************************************************************/
      .mode-switch { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
      .mode-switch button { padding: 6px 8px; border-radius: 8px; background:#222; border:1px solid #444; font-size:.85rem; }
      body.light .mode-switch button { background:#eef2f7; border-color:#cbd5e1; color:#0f172a; }
      .mode-switch button.active { outline: 2px solid #60a5fa; }

      /******************************************************************
       * [ORBITAL SPINNER]
       * - 여러 점이 원형으로 도는 로딩 애니메이션
       * - map loading, 앱 modal loading, 썸네일 loading에 재사용
       ******************************************************************/
      .orbital-spinner {
        position: relative;
        width: 56px;
        height: 56px;
        filter: drop-shadow(0 6px 18px rgba(0,0,0,.35));
      }
      .orbital-spinner.small { width: 28px; height: 28px; }
      .orbital-spinner .dot {
        position: absolute;
        top: 50%; left: 50%;
        width: 10px; height: 10px;
        margin: -5px 0 0 -5px;
        border-radius: 999px;
        background: rgba(255,255,255,.78);
        transform-origin: 0 0;
        animation: orbit 1.0s linear infinite;
      }
      .orbital-spinner.small .dot { width: 6px; height: 6px; margin: -3px 0 0 -3px; background: rgba(255,255,255,.72); }
      body.light .orbital-spinner .dot { background: rgba(15,23,42,.58); }
      body.light .orbital-spinner.small .dot { background: rgba(15,23,42,.52); }

      .orbital-spinner .dot:nth-child(1) { transform: rotate(0deg)   translate(22px); animation-delay: -0.0s; }
      .orbital-spinner .dot:nth-child(2) { transform: rotate(45deg)  translate(22px); animation-delay: -0.125s; }
      .orbital-spinner .dot:nth-child(3) { transform: rotate(90deg)  translate(22px); animation-delay: -0.25s; }
      .orbital-spinner .dot:nth-child(4) { transform: rotate(135deg) translate(22px); animation-delay: -0.375s; }
      .orbital-spinner .dot:nth-child(5) { transform: rotate(180deg) translate(22px); animation-delay: -0.5s; }
      .orbital-spinner .dot:nth-child(6) { transform: rotate(225deg) translate(22px); animation-delay: -0.625s; }
      .orbital-spinner .dot:nth-child(7) { transform: rotate(270deg) translate(22px); animation-delay: -0.75s; }
      .orbital-spinner .dot:nth-child(8) { transform: rotate(315deg) translate(22px); animation-delay: -0.875s; }

      .orbital-spinner.small .dot:nth-child(1) { transform: rotate(0deg)   translate(11px); }
      .orbital-spinner.small .dot:nth-child(2) { transform: rotate(45deg)  translate(11px); }
      .orbital-spinner.small .dot:nth-child(3) { transform: rotate(90deg)  translate(11px); }
      .orbital-spinner.small .dot:nth-child(4) { transform: rotate(135deg) translate(11px); }
      .orbital-spinner.small .dot:nth-child(5) { transform: rotate(180deg) translate(11px); }
      .orbital-spinner.small .dot:nth-child(6) { transform: rotate(225deg) translate(11px); }
      .orbital-spinner.small .dot:nth-child(7) { transform: rotate(270deg) translate(11px); }
      .orbital-spinner.small .dot:nth-child(8) { transform: rotate(315deg) translate(11px); }

      @keyframes orbit {
        0%   { opacity: .35; transform: rotate(0deg) translate(22px) scale(.85); }
        50%  { opacity: 1;   transform: rotate(180deg) translate(22px) scale(1.05); }
        100% { opacity: .35; transform: rotate(360deg) translate(22px) scale(.85); }
      }
      .orbital-spinner.small .dot { animation-name: orbitSmall; }
      @keyframes orbitSmall {
        0%   { opacity: .35; scale: .85; }
        50%  { opacity: 1;   scale: 1.05; }
        100% { opacity: .35; scale: .85; }
      }

      /******************************************************************
       * [APP LOADING MODAL]
       * - 앱 단위(구글 연결/폴더 준비/분석/저장) 작업 중 전체 UI를 잠그고 안내
       ******************************************************************/
      #app-loading {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: rgba(0,0,0,.55);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity .2s ease;
      }
      #app-loading.show { opacity: 1; pointer-events: auto; }
      #app-loading .panel {
        background: rgba(17,17,17,.92);
        border: 1px solid rgba(255,255,255,.12);
        border-radius: 16px;
        padding: 18px 18px 16px;
        min-width: 260px;
        max-width: min(440px, 92vw);
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        text-align: center;
      }
      body.light #app-loading .panel {
        background: rgba(255,255,255,.92);
        border: 1px solid rgba(15,23,42,.10);
        color: #0f172a;
      }
      #app-loading .msg { font-size: 14px; opacity: .9; line-height: 1.4; }
      #app-loading .sub { font-size: 12px; opacity: .7; line-height: 1.4; }
    </style>
  </head>

  <body>
    <!-- [GLOBAL APP LOADING MODAL] -->
    <div id="app-loading" aria-hidden="true">
      <div class="panel" role="status" aria-live="polite">
        <div class="orbital-spinner" aria-label="loading">
          <span class="dot"></span><span class="dot"></span><span class="dot"></span><span class="dot"></span>
          <span class="dot"></span><span class="dot"></span><span class="dot"></span><span class="dot"></span>
        </div>
        <div id="app-loading-msg" class="msg"></div>
        <div id="app-loading-sub" class="sub"></div>
      </div>
    </div>

    <div class="app">
      <!-- [LEFT: SIDEBAR] -->
      <div class="sidebar">
        <div class="sidebar-header">
          <div>
            <!-- 고정 문구는 initUIText()에서 주입 -->
            <h2 id="ui-title"></h2>
            <p id="ui-subtitle" style="margin: 6px 0 0; font-size: 0.75rem; opacity: 0.6"></p>
          </div>

          <!-- 테마 전환 버튼: 텍스트는 syncThemeButtonLabel()에서 관리 -->
          <button id="btnTheme"></button>
        </div>

        <div class="controls">
          <!-- [MODE SWITCH] -->
          <div class="mode-switch">
            <button id="modeBasic" class="active"></button>
            <button id="modeGlow"></button>
            <button id="modeDensity"></button>
          </div>

          <!-- [AUTH / PICKER FLOW]
               1) Google Drive 연결
               2) 폴더 선택
               3) 사진 불러오기 -->
          <button id="btnLogin"></button>
          <button id="btnPickFolder" disabled></button>
          <div id="pickedFolderLabel" style="font-size:.8rem;opacity:.75;"></div>

          <!-- [COLOR MODE] 대표색/팔레트/자동 -->
          <label id="ui-colorModeLabel" style="font-size: 0.75rem; opacity: 0.65"></label>
          <select id="colorMode">
            <option value="auto" selected></option>
            <option value="photo"></option>
            <option value="firework"></option>
          </select>

          <!-- [LOAD / RESET] -->
          <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px;">
            <button id="btnLoad" disabled></button>
            <button id="btnReset"></button>
          </div>

          <!-- 상태 메세지 출력 영역 -->
          <div id="status" class="status-box"></div>
        </div>

        <!-- 사진 목록 -->
        <div id="photoList" class="photo-list"></div>
      </div>

      <!-- [RIGHT: MAP AREA] -->
      <div class="map-wrap">
        <!-- [TIMELINE BAR] 월 단위 필터 -->
        <div id="timeline-bar">
          <input id="timeline-range" type="range" min="0" max="0" value="0" disabled />
          <div id="timeline-label"></div>
        </div>

        <!-- [DENSITY MODE: REGION LEVEL CONTROLS] -->
        <div id="region-controls" style="display:none;">
          <div id="ui-regionTitle" style="font-weight:600;margin-bottom:6px;"></div>
          <label style="display:block;margin-bottom:4px;cursor:pointer;">
            <input type="radio" name="region-level" value="sido" checked> <span id="ui-regionSido"></span>
          </label>
          <label style="display:block;cursor:pointer;">
            <input type="radio" name="region-level" value="sigungu"> <span id="ui-regionSigungu"></span>
          </label>
        </div>

        <!-- [DENSITY MODE: LEGEND] -->
        <div id="density-legend" style="display:none;">
          <div id="ui-legendTitle" style="font-weight:600;margin-bottom:6px;"></div>
          <div id="legend-scale" style="display:flex;gap:2px;"></div>
          <div id="legend-range" style="font-size:12px;opacity:.9;">0 ~ 0</div>
        </div>

        <!-- [DENSITY MODE: PALETTE POPUP] -->
        <div id="density-palette-pop">
          <div id="ui-paletteTitle" class="pop-title"></div>
          <div class="pop-grid">
            <button class="pop-opt" data-pal="blue"><span class="swatch" data-pal="blue"></span><span id="ui-palBlue"></span></button>
            <button class="pop-opt" data-pal="red"><span class="swatch" data-pal="red"></span><span id="ui-palRed"></span></button>
            <button class="pop-opt" data-pal="orange"><span class="swatch" data-pal="orange"></span><span id="ui-palOrange"></span></button>
            <button class="pop-opt" data-pal="yellow"><span class="swatch" data-pal="yellow"></span><span id="ui-palYellow"></span></button>
          </div>
          <div id="ui-paletteHint" class="pop-hint"></div>
        </div>

        <!-- Mapbox 컨테이너 -->
        <div id="map"></div>

        <!-- 맵 로딩 오버레이 -->
        <div id="map-loading">
          <div class="orbital-spinner" aria-label="loading">
            <span class="dot"></span><span class="dot"></span><span class="dot"></span><span class="dot"></span>
            <span class="dot"></span><span class="dot"></span><span class="dot"></span><span class="dot"></span>
          </div>
          <div id="map-loading-msg" style="opacity:.92;"></div>
        </div>
      </div>
    </div>

    <!-- 라이브러리 로드 순서 주의:
         - mapboxgl은 map 초기화 전에 필요
         - google gsi/client는 oauth2 토큰 발급에 필요
         - gapi는 picker 로딩에 필요 -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

    <script>
      /******************************************************************
       * UI_TEXT: UI 문자열 단일 관리 지점
       * - 문구 변경이 필요한 경우 이 객체만 수정하면 UI 전반이 반영됨.
       * - 다국어 확장 시: UI_TEXT를 locale별 객체로 분리하거나 i18n 테이블화
       ******************************************************************/
      const UI_TEXT = {
        app: {
          title: "Photo Map Explorer",
          subtitle: "",
          themeDark: "Dark",
          themeLight: "Light",
        },

        mode: {
          basic: "Basic",
          glow: "Glow",
          density: "Density",
          statusBasic: "Basic 모드: 썸네일과 클러스터를 표시합니다.",
          statusGlow: "Glow 모드: 사진 위치를 색으로 강조합니다.",
          statusDensity: "Density 모드: 지역별 사진 분포를 표시합니다.",
        },

        auth: {
          connect: "Google Drive 연결",
          connectProgressStatus: "Google 계정에 연결하는 중입니다…",
          connectModalTitle: "Google Drive에 연결하는 중입니다",
          connectModalSub: "권한 확인이 끝나면 폴더를 선택할 수 있어요",
          connectFail: "Google Drive에 연결하지 못했습니다. 다시 시도해 주세요.",
          restoredToken: "이전에 연결한 계정 정보를 불러왔습니다. 폴더를 선택해 주세요.",
          needConnect: "먼저 Google Drive를 연결해 주세요.",
          tokenNotReady: "Google 인증 모듈이 아직 준비되지 않았습니다. 잠시 후 다시 시도해 주세요.",
          pickerNotReady: "Google Picker가 아직 준비되지 않았습니다. 잠시 후 다시 시도해 주세요.",
          expired: "Google 연결이 만료되었습니다. 다시 연결해 주세요.",
          done: "Google Drive 연결이 완료되었습니다. 사진 폴더를 선택해 주세요.",
        },

        folder: {
          pick: "사진 폴더 선택",
          pickedNone: "선택된 폴더: 없음",
          picked: "선택된 폴더: {name}",
          pickReadyStatus: "폴더 선택기를 준비하고 있어요…",
          pickReadyModalTitle: "폴더 선택기를 준비하고 있어요",
          pickReadyModalSub: "잠시만 기다려 주세요",
          pickFail: "폴더 선택기를 열지 못했습니다. 잠시 후 다시 시도해 주세요.",
          pickedStatus: "폴더를 선택했습니다. 이제 사진을 불러올 수 있어요.",
          cancelled: "폴더 선택이 취소되었습니다.",
          pickerTitle: "Photo Map Explorer - 폴더 선택",
        },

        load: {
          btnNeedFolder: "폴더를 먼저 선택해 주세요",
          btnLoad: "사진 불러오기",
          mapReady: "지도가 준비되었습니다. Google Drive를 연결해 주세요.",
          mapLoading: "지도를 불러오고 있어요",
          mapApplyLight: "밝은 지도를 적용하는 중입니다",
          mapApplyDark: "어두운 지도를 적용하는 중입니다",

          appLoadingTitleDefault: "사진을 준비하고 있어요",
          appLoadingSubDefault: "Google Drive에서 사진을 불러와 지도에 정리하고 있습니다",

          flowSub: "이전에 분석한 데이터 확인 → 변경 여부 확인 → 필요한 경우 분석합니다",
          checkingCache: "이전에 분석한 데이터를 확인하고 있어요…",
          oldCache: "이전 버전 데이터가 있어 최신 형식으로 다시 정리합니다…",
          checkingFolder: "폴더 변경 여부를 확인하고 있어요…",
          checkingFolderModalTitle: "폴더 상태를 확인하고 있어요",
          checkingFolderModalSub: "변경된 사진이 있는지 확인 중입니다",

          reuseCache: "분석을 완료했습니다.",
          firstTime: "처음 분석하는 폴더입니다. 사진을 정리해 볼게요. (위치 정보 사진: {count}장)",
          changed: "폴더 내용이 바뀐 것 같아요. 다시 정리합니다. (위치 정보 사진: {count}장)",
          refresh: "데이터를 최신 상태로 다시 정리합니다. (위치 정보 사진: {count}장)",

          listModalTitle: "사진 목록을 불러오고 있어요",
          listModalSub: "위치 정보가 있는 사진만 모읍니다",

          noGeoPhotos: "이 폴더에는 위치 정보가 포함된 사진이 없습니다.",
          foundPhotos: "사진 {count}장을 찾았습니다. 대표색을 분석하고 있어요…",
          analyzeModalTitle: "사진을 정리하고 있어요",
          analyzeModalSub: "총 {count}장을 분석합니다 (시간이 조금 걸릴 수 있어요)",
          analyzingProgress: "사진을 정리하고 있어요… ({done}/{total})",
          analyzeModalProgressSub: "{done}/{total}장 처리 완료",

          applyModalTitle: "지도에 표시하는 중입니다",
          applyModalSub: "목록과 지도에 사진을 배치합니다",

          saving: "분석 결과를 저장하고 있어요…",
          savingModalTitle: "분석 결과를 저장하고 있어요",
          savingModalSub: "다음부터 더 빠르게 불러올 수 있습니다",
          doneSaved: "사진을 지도에 표시했습니다. 다음부터는 더 빠르게 열립니다.",

          errRefresh: "문제가 발생했습니다. 새로고침 후 다시 시도해 주세요.",
          mapNotReady: "지도가 아직 준비되지 않았습니다. 잠시만 기다려 주세요.",
          needFolder: "사진을 불러오려면 먼저 폴더를 선택해 주세요.",
        },

        timeline: {
          noDate: "",
          all: "전체 기간 보기",
          label: "{y}년 {m}월 ({count}장)",
        },

        colorMode: {
          label: "색상 모드",
          auto: "자동",
          photo: "대표색",
          firework: "팔레트",
        },

        reset: {
          btn: "로그아웃",
          status: "초기화되었습니다. 다시 Google Drive를 연결해 주세요.",
        },

        density: {
          regionTitle: "지역별 사진 개수",
          bySido: "시도 기준",
          bySigungu: "시군구 기준",
          legendTitle: "사진 개수",
          paletteTitle: "색상",
          palBlue: "파랑",
          palRed: "빨강",
          palOrange: "주황",
          palYellow: "노랑",
          paletteHint: "범례를 다시 누르거나 바깥을 클릭하면 닫힙니다",
        },

        popup: {
          photoLoading: "사진을 불러오고 있어요",
          photoUnavailable: "미리보기를 표시할 수 없습니다",
          photoFail: "사진을 불러오지 못했습니다",
          weatherLoading: "촬영 당시의 날씨를 불러오는 중입니다",
          weatherNoDate: "날씨 정보: 촬영 날짜를 확인할 수 없습니다",
          weatherUnavailable: "날씨 정보: 표시할 수 없습니다",
          weatherFail: "날씨 정보를 불러오지 못했습니다",
          weatherTitle: "촬영일 날씨",
          temp: "평균기온",
          weather: "날씨",
          rain: "강수량",
          openMeteo: "{dateStr} · Open-Meteo",
        },

        regionPopup: {
          titleFallback: "선택한 지역",
          photoCount: "사진 {count}장",
          none: "이 지역에는 위치 정보 사진이 없습니다.",
        }
      };

      /******************************************************************
       * i18n Helper
       * - t("a.b.c") 형태로 문자열을 꺼내고, {var} 치환까지 수행
       ******************************************************************/
      function formatText(template, vars = {}) {
        return String(template).replace(/\{(\w+)\}/g, (_, k) => (vars[k] ?? `{${k}}`));
      }
      function t(path, vars) {
        const keys = path.split(".");
        let cur = UI_TEXT;
        for (const k of keys) cur = cur?.[k];
        if (typeof cur !== "string") return path; // 잘못된 키면 path를 그대로 노출 (디버깅 용이)
        return formatText(cur, vars);
      }

      /******************************************************************
       * CONFIG / SECRETS
       * - 실제 배포 시: 환경변수/서버 프록시/secret manager로 분리 권장
       ******************************************************************/
      const MAPBOX_TOKEN = "pk.eyJ1IjoiY2hvY293b25ueSIsImEiOiJjbWg5dmJvOGoxajUyMmtzNXRianRmazkxIn0.iRc3ft0YLDvywX9OOtIeXA";
      const GOOGLE_CLIENT_ID = "812584123635-7hg0vagtcqh26u1510s782s0jrn90go4.apps.googleusercontent.com";
      const GOOGLE_API_KEY = "AIzaSyCRI2g5bMoA64yTvizzh74JczH3uwGJoYU";
      mapboxgl.accessToken = MAPBOX_TOKEN;

      /******************************************************************
       * TOKEN STORAGE
       * - access_token은 브라우저 localStorage에 저장(간편)
       * - 보안/만료 관리가 핵심: expiresAt 기준으로 만료 토큰은 폐기
       ******************************************************************/
      const TOKEN_STORAGE_KEY = "pme_gdrive_access_token";
      const TOKEN_EXPIRES_KEY = "pme_gdrive_access_token_expires_at";

      /******************************************************************
       * DENSITY MODE BOUNDARIES
       * - 시도/시군구 경계 GeoJSON
       ******************************************************************/
      const SIDO_GEOJSON_URL    = "./geojson/korea_sido.geojson";
      const SIGUNGU_GEOJSON_URL = "./geojson/korea_sigungu.geojson";

      /******************************************************************
       * DOM REFS
       * - query 비용을 줄이고, 코드 가독성을 위해 상단에서 모두 캐싱
       ******************************************************************/
      const statusEl = document.getElementById("status");
      const btnLogin = document.getElementById("btnLogin");
      const btnPickFolder = document.getElementById("btnPickFolder");
      const pickedFolderLabel = document.getElementById("pickedFolderLabel");

      const btnLoad = document.getElementById("btnLoad");
      const btnReset = document.getElementById("btnReset");
      const photoListEl = document.getElementById("photoList");
      const mapLoadingEl = document.getElementById("map-loading");
      const mapLoadingMsg = document.getElementById("map-loading-msg");

      const btnTheme = document.getElementById("btnTheme");
      const timelineRange = document.getElementById("timeline-range");
      const timelineLabel = document.getElementById("timeline-label");
      const colorModeSelect = document.getElementById("colorMode");
      const legendScale = document.getElementById("legend-scale");
      const legendRange = document.getElementById("legend-range");

      const densityLegendEl = document.getElementById("density-legend");
      const densityPalettePop = document.getElementById("density-palette-pop");

      const appLoadingEl = document.getElementById("app-loading");
      const appLoadingMsg = document.getElementById("app-loading-msg");
      const appLoadingSub = document.getElementById("app-loading-sub");

      const modeBasicBtn   = document.getElementById("modeBasic");
      const modeGlowBtn    = document.getElementById("modeGlow");
      const modeDensityBtn = document.getElementById("modeDensity");

      /******************************************************************
       * RUNTIME STATE
       * - map: Mapbox 인스턴스
       * - isMapReady: load 이벤트 이후 true
       * - driveAccessToken: OAuth access_token(만료되면 즉시 폐기)
       ******************************************************************/
      let map = null, isMapReady = false, driveAccessToken = null, selectedPhotoId = null;
      let selectedFolderId = null;
      let selectedFolderName = null;

      /******************************************************************
       * UI STATE
       * - theme / timeline / color mode / map mode
       ******************************************************************/
      let currentTheme = "dark";
      let allPhotos = [];      // 전체 데이터(필터 적용 전)
      let lastPhotos = [];     // 현재 맵에 반영된 데이터(필터 적용 후)
      let timelineMonths = []; // 월 단위 집계 결과
      let currentTimelineIndex = -1; // -1 = 전체 보기
      let currentColorMode = "auto";

      /******************************************************************
       * DENSITY STATE
       * - boundaryCache: GeoJSON 로딩 캐시 (네트워크 비용 절감)
       ******************************************************************/
      let boundaryCache = { sido: null, sigungu: null };
      let currentLevel = "sido";
      let maxCountGlobal = 0;

      /******************************************************************
       * EVENT BINDING GUARDS
       * - Mapbox layer click은 중복 바인딩하면 이벤트가 누적됨
       ******************************************************************/
      let photosCoreClickBound = false;
      let currentMapMode = "basic";

      /******************************************************************
       * PALETTES
       * - FIREWORK_PALETTE: 사진별 팔레트 색(대표색 추출 실패 시 fallback)
       * - CHORO_PALETTES: density 모드 choropleth 색상
       ******************************************************************/
      const FIREWORK_PALETTE = ["#ffcc00","#ff6f00","#ff4081","#f50057","#ff8a80","#ff80ab","#ea80fc","#b388ff","#82b1ff","#448aff","#18ffff","#64ffda","#69f0ae","#00e676","#ffee58","#ffd740"];

      const CHORO_PALETTES = {
        blue:   ["#dbeafe","#93c5fd","#60a5fa","#3b82f6","#2563eb","#1d4ed8","#1e40af"],
        red:    ["#fee2e2","#fecaca","#fca5a5","#ef4444","#dc2626","#b91c1c","#7f1d1d"],
        orange: ["#ffedd5","#fed7aa","#fdba74","#f97316","#ea580c","#c2410c","#7c2d12"],
        yellow: ["#fef9c3","#fef08a","#fde047","#eab308","#ca8a04","#a16207","#713f12"],
      };

      let currentDensityPaletteKey = "blue";
      let CHORO_COLORS = CHORO_PALETTES[currentDensityPaletteKey].slice();

      /******************************************************************
       * WEATHER CACHE
       * - 동일 좌표/날짜 요청 중복을 방지 (네트워크 절약)
       * - Promise를 먼저 넣었다가 resolve 후 실제 값을 다시 set 하는 패턴 사용
       ******************************************************************/
      const weatherCache = new Map();

      /******************************************************************
       * CANVAS (대표색 추출 등 이미지 분석용)
       * - willReadFrequently: getImageData 등 잦은 읽기에 유리
       ******************************************************************/
      const sharedCanvas = document.createElement("canvas");
      const sharedCtx = sharedCanvas.getContext("2d", { willReadFrequently: true });

      /******************************************************************
       * CACHE SCHEMA
       * - Google Drive 폴더 안에 `${folderId}.json` 형태로 캐시 저장
       * - schemaVersion으로 구조 변경 대응
       ******************************************************************/
      const CACHE_SCHEMA_VERSION = 2;
      let cacheFileName = null;

      /******************************************************************
       * THUMBNAIL OBJECT URL CACHE
       * - Drive에서 원본 blob을 받아, 작은 JPEG로 리사이즈 후 objectURL 생성
       * - objectURL은 반드시 revoke하여 메모리 누수 방지
       ******************************************************************/
      const thumbObjectUrlByPhotoId = new Map();
      const thumbBuildPromiseByPhotoId = new Map();
      const THUMB_MAX_SIZE = 128;

      /******************************************************************
       * FALLBACK SPRITE
       * - map 스타일에 이미지가 없을 때(또는 썸네일 준비 전) 표시되는 기본 아이콘
       ******************************************************************/
      const FALLBACK_SPRITE_ID = "thumb-fallback";

      /******************************************************************
       * UI INIT
       * - HTML은 비워두고, JS에서 문구/라벨을 주입한다.
       * - 유지보수 포인트: UI_TEXT만 바꾸면 전체 문구가 변경됨
       ******************************************************************/
      function initUIText() {
        document.getElementById("ui-title").textContent = t("app.title");
        document.getElementById("ui-subtitle").textContent = t("app.subtitle");

        modeBasicBtn.textContent = t("mode.basic");
        modeGlowBtn.textContent = t("mode.glow");
        modeDensityBtn.textContent = t("mode.density");

        btnLogin.textContent = t("auth.connect");
        btnPickFolder.textContent = t("folder.pick");

        document.getElementById("ui-colorModeLabel").textContent = t("colorMode.label");
        const opts = colorModeSelect.querySelectorAll("option");
        opts[0].textContent = t("colorMode.auto");
        opts[1].textContent = t("colorMode.photo");
        opts[2].textContent = t("colorMode.firework");

        btnReset.textContent = t("reset.btn");

        document.getElementById("ui-regionTitle").textContent = t("density.regionTitle");
        document.getElementById("ui-regionSido").textContent = t("density.bySido");
        document.getElementById("ui-regionSigungu").textContent = t("density.bySigungu");
        document.getElementById("ui-legendTitle").textContent = t("density.legendTitle");

        document.getElementById("ui-paletteTitle").textContent = t("density.paletteTitle");
        document.getElementById("ui-palBlue").textContent = t("density.palBlue");
        document.getElementById("ui-palRed").textContent = t("density.palRed");
        document.getElementById("ui-palOrange").textContent = t("density.palOrange");
        document.getElementById("ui-palYellow").textContent = t("density.palYellow");
        document.getElementById("ui-paletteHint").textContent = t("density.paletteHint");

        pickedFolderLabel.textContent = t("folder.pickedNone");

        // Load 버튼은 폴더 선택 전까지 비활성/안내 문구
        btnLoad.textContent = t("load.btnNeedFolder");

        // 초기 상태 메시지
        statusEl.textContent = t("load.mapLoading");
        timelineLabel.textContent = t("timeline.noDate");

        syncThemeButtonLabel();
        setMapLoadingText(t("load.mapLoading"));
      }

      function syncThemeButtonLabel() {
        // 현재 테마 상태를 버튼 라벨에 반영
        btnTheme.textContent = (currentTheme === "dark") ? t("app.themeDark") : t("app.themeLight");
      }

      function setMapLoadingText(msg) {
        if (mapLoadingMsg) mapLoadingMsg.textContent = msg;
      }

      // 문구 주입은 최초 1회 수행
      initUIText();

      /******************************************************************
       * GLOBAL LOADING CONTROLS
       * - "앱 전체 로딩"과 "맵 로딩"을 분리해 UX를 세밀하게 제어
       ******************************************************************/
      function showAppLoading(msg = t("load.appLoadingTitleDefault"), sub = t("load.appLoadingSubDefault")) {
        if (!appLoadingEl) return;
        if (appLoadingMsg) appLoadingMsg.textContent = msg;
        if (appLoadingSub) appLoadingSub.textContent = sub;
        appLoadingEl.classList.add("show");
      }
      function hideAppLoading() {
        if (!appLoadingEl) return;
        appLoadingEl.classList.remove("show");
      }
      function showMapLoading(msg = t("load.mapLoading")) {
        if (!mapLoadingEl) return;
        setMapLoadingText(msg);
        mapLoadingEl.classList.remove("hide");
      }
      function hideMapLoading() {
        if (!mapLoadingEl) return;
        mapLoadingEl.classList.add("hide");
      }

      /******************************************************************
       * CACHE FILE NAME STRATEGY
       * - 폴더ID 기반 파일명: `${folderId}.json`
       * - 폴더별 캐시를 Drive에 저장하므로, 폴더 단위로 재사용 가능
       ******************************************************************/
      function getCacheFileNameByFolderId(folderId){
        return `${folderId}.json`;
      }

      /******************************************************************
       * TOKEN PERSISTENCE
       * - expiresInSec 기반으로 expiresAt을 저장해 만료 토큰을 재사용하지 않게 함
       ******************************************************************/
      function saveToken(accessToken, expiresInSec) {
        const expiresAt = Date.now() + Number(expiresInSec || 0) * 1000;
        localStorage.setItem(TOKEN_STORAGE_KEY, accessToken);
        localStorage.setItem(TOKEN_EXPIRES_KEY, String(expiresAt));
      }

      function loadStoredToken() {
        const token = localStorage.getItem(TOKEN_STORAGE_KEY);
        const expiresAt = Number(localStorage.getItem(TOKEN_EXPIRES_KEY) || "0");
        if (!token || !expiresAt) return null;
        if (Date.now() >= expiresAt) return null;
        return token;
      }

      function clearStoredToken() {
        localStorage.removeItem(TOKEN_STORAGE_KEY);
        localStorage.removeItem(TOKEN_EXPIRES_KEY);
      }

      /******************************************************************
       * UI STATE WHEN LOGGED IN
       * - 로그인 후: 폴더 선택 가능
       * - load는 폴더 선택 후에만 활성화
       ******************************************************************/
      function applyLoggedInUI() {
        btnLogin.disabled = true;
        btnPickFolder.disabled = false;
        btnLoad.disabled = true;
        btnLoad.textContent = t("load.btnNeedFolder");
      }

      function setStatus(msg){ statusEl.textContent = msg; }

      /******************************************************************
       * DATE PARSING
       * - Drive 메타데이터 time 포맷이 케이스별로 달라질 수 있어
       *   여러 규칙으로 "최대한 안전하게" Date 객체로 파싱
       ******************************************************************/
      function parsePhotoDate(str){
        if (!str) return null;

        // 1) JS Date가 바로 먹는 ISO 류
        const d1 = new Date(str);
        if (!isNaN(d1.getTime())) return d1;

        // 2) EXIF 형태: "YYYY:MM:DD HH:MM:SS" 대응
        const m = str.match(/^(\d{4}):(\d{2}):(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
        if (m) {
          const d2 = new Date(`${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}Z`);
          if (!isNaN(d2.getTime())) return d2;
        }

        // 3) 약식/혼합 포맷 방어
        if (str[4]===":" && str[7]===":"){
          const guess = str.slice(0,4)+"-"+str.slice(5,7)+"-"+str.slice(8,10)+"T"+str.slice(11).replace(" ","T")+"Z";
          const d3 = new Date(guess);
          if (!isNaN(d3.getTime())) return d3;
        }
        return null;
      }

      /******************************************************************
       * yyyy-mm-dd (LOCAL TIME)
       * - 날씨 아카이브 API는 날짜 범위를 요구하므로 날짜를 문자열로 통일
       ******************************************************************/
      function ymdLocal(d){
        const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,"0"), da=String(d.getDate()).padStart(2,"0");
        return `${y}-${m}-${da}`;
      }

      /******************************************************************
       * COLOR PICKING
       * - 현재 색상 모드에 따라 사진에 적용할 색상을 결정
       ******************************************************************/
      function pickColorForPhoto(p){
        if (currentColorMode==="photo") return p.dominantColor || p.paletteColor || "#cccccc";
        if (currentColorMode==="firework") return p.paletteColor || p.dominantColor || "#cccccc";
        return p.dominantColor || p.paletteColor || "#cccccc";
      }

      /******************************************************************
       * mapLimit: 제한된 동시성(Concurrency)으로 async 작업 수행
       * - 대표색 분석/썸네일 생성 등 병렬 처리에서 브라우저 과부하 방지
       ******************************************************************/
      function mapLimit(arr, limit, iteratee){
        const result = new Array(arr.length);
        let idx = 0;
        const workers = Array.from({length: limit}, async () => {
          while (true) {
            const cur = idx++;
            if (cur>=arr.length) break;
            result[cur] = await iteratee(arr[cur], cur);
          }
        });
        return Promise.all(workers).then(()=>result);
      }

      /******************************************************************
       * SHA-256 HELPER
       * - 폴더 내 "위치정보 포함 사진 id 목록"을 정렬 후 해시하여
       *   캐시 재사용 가능 여부를 빠르게 판단
       ******************************************************************/
      async function sha256Hex(str){
        const enc = new TextEncoder().encode(str);
        const buf = await crypto.subtle.digest("SHA-256", enc);
        const bytes = Array.from(new Uint8Array(buf));
        return bytes.map(b => b.toString(16).padStart(2,"0")).join("");
      }

      /******************************************************************
       * listDriveGeoPhotoIds
       * - Drive folder에서 image/* 파일을 페이징 조회
       * - 그 중 GPS(lat/lon)가 있는 파일 id만 모아서 반환
       *
       * 401 처리:
       * - 토큰 만료/철회 시 즉시 localStorage 삭제 + UI를 로그인 상태로 되돌림
       ******************************************************************/
      async function listDriveGeoPhotoIds(accessToken, folderId){
        const ids = [];
        let pageToken;

        while (true) {
          const params = new URLSearchParams({
            q: `'${folderId}' in parents and mimeType contains 'image/' and trashed=false`,
            fields: "files(id,imageMediaMetadata(location)),nextPageToken",
            pageSize: "1000",
          });
          if (pageToken) params.set("pageToken", pageToken);

          const res = await fetch("https://www.googleapis.com/drive/v3/files?" + params.toString(), {
            headers: { Authorization: `Bearer ${accessToken}` }
          });

          if (res.status === 401) {
            // 토큰 만료/무효 → 상태 리셋
            clearStoredToken();
            driveAccessToken = null;
            btnLogin.disabled = false;
            btnPickFolder.disabled = true;
            btnLoad.disabled = true;
            btnLoad.textContent = t("load.btnNeedFolder");
            throw new Error(t("auth.expired"));
          }

          if (!res.ok) {
            const tt = await res.text().catch(()=> "");
            throw new Error("Drive 목록을 불러오지 못했습니다: " + res.status + " " + tt);
          }

          const data = await res.json();
          for (const f of (data.files ?? [])) {
            const loc = f.imageMediaMetadata?.location;
            if (loc?.latitude && loc?.longitude) ids.push(f.id);
          }

          pageToken = data.nextPageToken;
          if (!pageToken) break;
        }

        return ids;
      }

      /******************************************************************
       * computePhotoIdHashFromFolder
       * - 폴더의 위치정보 사진 id들을 정렬하고, 하나의 시그니처 문자열로 만들고 해시
       * - 캐시 JSON 안의 photoIdHash와 비교하여 재분석 여부 결정
       ******************************************************************/
      async function computePhotoIdHashFromFolder(accessToken, folderId){
        const ids = await listDriveGeoPhotoIds(accessToken, folderId);
        ids.sort();
        const signature = ids.join(",");
        const hash = await sha256Hex(signature);
        return { ids, hash, count: ids.length };
      }

      function round2(x){ return Math.round(x*100)/100; }

      /******************************************************************
       * OPEN-METEO 날씨 코드 → 한국어
       * - Open-Meteo weathercode 표준을 UI용 텍스트로 변환
       ******************************************************************/
      function weatherCodeToKorean(code){
        if (code == null || code === undefined) return "정보 없음";
        const c = Number(code);
        if (c === 0) return "맑음";
        if (c === 1) return "대체로 맑음";
        if (c === 2) return "구름 조금";
        if (c === 3) return "흐림";
        if (c === 45 || c === 48) return "안개";
        if ([51,53,55].includes(c)) return "이슬비";
        if ([56,57].includes(c)) return "어는 이슬비";
        if ([61,63,65].includes(c)) return "비";
        if ([66,67].includes(c)) return "어는 비";
        if ([71,73,75].includes(c)) return "눈";
        if (c === 77) return "싸락눈";
        if ([80,81,82].includes(c)) return "소나기";
        if ([85,86].includes(c)) return "눈 소나기";
        if (c === 95) return "뇌우";
        if ([96,99].includes(c)) return "우박 동반 뇌우";
        return `기타(${c})`;
      }

      /******************************************************************
       * fetchDailyWeather
       * - Open-Meteo Archive API를 사용하여 촬영일의 일간 평균기온/강수량/코드 조회
       * - timezone을 Asia/Seoul로 지정하여 날짜 경계가 KST 기준이 되도록 함
       ******************************************************************/
      async function fetchDailyWeather(lat, lon, dateStr){
        const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${dateStr}&end_date=${dateStr}&daily=temperature_2m_mean,precipitation_sum,weathercode&timezone=Asia/Seoul`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Weather HTTP " + res.status);
        const data = await res.json();
        if (!data.daily) return null;
        return {
          temp: data.daily.temperature_2m_mean?.[0] ?? null,
          rain: data.daily.precipitation_sum?.[0] ?? null,
          code: data.daily.weathercode?.[0] ?? null
        };
      }

      /******************************************************************
       * getWeatherCached
       * - 요청 key를 lat/lon 2자리 반올림 + dateStr로 구성하여 캐시 hit율을 올림
       * - 동일 key에 대해 중복 fetch를 막기 위해 Promise 캐싱 패턴 사용
       ******************************************************************/
      async function getWeatherCached(lat, lon, dateStr){
        const key = `${round2(lat)},${round2(lon)}|${dateStr}`;
        const cached = weatherCache.get(key);
        if (cached) return cached;

        const p = fetchDailyWeather(lat, lon, dateStr).catch(()=>null);
        weatherCache.set(key, p);

        const data = await p;
        weatherCache.set(key, data);
        return data;
      }

      /******************************************************************
       * fetchDriveImageBlob
       * - Drive fileId 원본을 alt=media로 blob 다운로드
       * - 썸네일/팝업 프리뷰 모두 여기서 파생
       ******************************************************************/
      async function fetchDriveImageBlob(fileId, accessToken){
        const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
          headers: { Authorization: `Bearer ${accessToken}` }
        });
        if (res.status === 401) {
          clearStoredToken();
          driveAccessToken = null;
          btnLogin.disabled = false;
          btnPickFolder.disabled = true;
          btnLoad.disabled = true;
          btnLoad.textContent = t("load.btnNeedFolder");
          throw new Error(t("auth.expired"));
        }
        if (!res.ok) throw new Error("사진을 불러오지 못했습니다: " + res.status);
        return await res.blob();
      }

      /******************************************************************
       * makeThumbObjectUrlFromBlob
       * - blob을 THUMB_MAX_SIZE 내로 리사이즈하여 objectURL 생성
       * - createImageBitmap 경로(성능/품질 좋음) → 실패 시 <img> fallback 경로
       ******************************************************************/
      async function makeThumbObjectUrlFromBlob(blob, size = THUMB_MAX_SIZE){
        try {
          const bmp = await createImageBitmap(blob, { resizeWidth: size, resizeHeight: size, resizeQuality: "high" });
          const c = document.createElement("canvas");
          c.width = bmp.width; c.height = bmp.height;
          const ctx = c.getContext("2d");
          ctx.drawImage(bmp, 0, 0);
          const outBlob = await new Promise(r => c.toBlob(r, "image/jpeg", 0.85));
          return URL.createObjectURL(outBlob);
        } catch {
          // fallback: blob → objectURL → <img> 로딩 → canvas draw
          const tempUrl = URL.createObjectURL(blob);
          try {
            const img = await new Promise((resolve, reject) => {
              const i = new Image();
              i.onload = () => resolve(i);
              i.onerror = reject;
              i.src = tempUrl;
            });
            const ratio = Math.min(size / img.width, size / img.height, 1);
            const w = Math.max(1, Math.round(img.width * ratio));
            const h = Math.max(1, Math.round(img.height * ratio));
            const c = document.createElement("canvas");
            c.width = w; c.height = h;
            const ctx = c.getContext("2d");
            ctx.drawImage(img, 0, 0, w, h);
            const outBlob = await new Promise(r => c.toBlob(r, "image/jpeg", 0.85));
            return URL.createObjectURL(outBlob);
          } finally {
            URL.revokeObjectURL(tempUrl);
          }
        }
      }

      /******************************************************************
       * getThumbObjectUrl
       * - (1) 이미 만들었으면 캐시 반환
       * - (2) 생성 중이면 inflight Promise를 await
       * - (3) 없으면 Drive에서 blob 다운로드 → 리사이즈 → objectURL 생성
       ******************************************************************/
      async function getThumbObjectUrl(photo){
        const cached = thumbObjectUrlByPhotoId.get(photo.id);
        if (cached) return cached;

        const inflight = thumbBuildPromiseByPhotoId.get(photo.id);
        if (inflight) return await inflight;

        const p = (async ()=>{
          if (!driveAccessToken) throw new Error(t("auth.needConnect"));
          const blob = await fetchDriveImageBlob(photo.id, driveAccessToken);
          const objUrl = await makeThumbObjectUrlFromBlob(blob, THUMB_MAX_SIZE);
          thumbObjectUrlByPhotoId.set(photo.id, objUrl);
          return objUrl;
        })();

        thumbBuildPromiseByPhotoId.set(photo.id, p);

        try {
          return await p;
        } finally {
          thumbBuildPromiseByPhotoId.delete(photo.id);
        }
      }

      /******************************************************************
       * clearThumbObjectUrls
       * - objectURL은 브라우저 메모리를 점유하므로 반드시 revoke 필요
       * - reset/폴더 변경 시 호출하여 누수 방지
       ******************************************************************/
      function clearThumbObjectUrls(){
        for (const url of thumbObjectUrlByPhotoId.values()){
          try { URL.revokeObjectURL(url); } catch {}
        }
        thumbObjectUrlByPhotoId.clear();
        thumbBuildPromiseByPhotoId.clear();
      }

      /******************************************************************
       * createFallbackThumbImageData / ensureFallbackSprite
       * - Mapbox symbol layer에 썸네일 sprite가 준비되지 않았을 때 표시할 기본 이미지
       * - canvas로 즉석 생성하여 map.addImage로 등록
       ******************************************************************/
      function createFallbackThumbImageData(){
        const c = document.createElement("canvas");
        c.width = 64; c.height = 64;
        const ctx = c.getContext("2d");

        ctx.fillStyle = "rgba(255,255,255,0.08)";
        ctx.fillRect(0,0,64,64);

        ctx.save();
        ctx.beginPath();
        ctx.arc(32,32,30,0,Math.PI*2);
        ctx.clip();

        const g = ctx.createLinearGradient(0,0,64,64);
        g.addColorStop(0, "rgba(96,165,250,0.55)");
        g.addColorStop(1, "rgba(244,114,182,0.45)");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,64,64);

        ctx.fillStyle = "rgba(15,23,42,0.35)";
        ctx.beginPath();
        ctx.moveTo(8,48); ctx.lineTo(28,28); ctx.lineTo(44,40); ctx.lineTo(56,30); ctx.lineTo(56,56); ctx.lineTo(8,56);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.beginPath();
        ctx.arc(46,20,6,0,Math.PI*2);
        ctx.fill();

        ctx.restore();

        return ctx.getImageData(0,0,64,64);
      }

      function ensureFallbackSprite(){
        if (!map) return;
        if (map.hasImage(FALLBACK_SPRITE_ID)) return;
        const imgData = createFallbackThumbImageData();
        map.addImage(FALLBACK_SPRITE_ID, imgData, { pixelRatio: 2 });
      }

      /******************************************************************
       * Lazy Sprite Injection: styleimagemissing
       * - Mapbox는 layer가 참조한 icon-image가 없으면 styleimagemissing 이벤트 발생
       * - 이 훅을 이용해 "필요할 때만" 썸네일 sprite를 생성/등록
       ******************************************************************/
      async function ensureOneThumbSpriteById(photoId){
        if (!map || !driveAccessToken) return;
        const spriteId = `thumb-${photoId}`;
        if (map.hasImage(spriteId)) return;

        const ph = (lastPhotos && lastPhotos.length ? lastPhotos : allPhotos).find(x => x.id === photoId);
        if (!ph) return;

        try {
          const objUrl = await getThumbObjectUrl(ph);
          const img = await loadImageAsync(objUrl);
          if (!map.hasImage(spriteId)) {
            map.addImage(spriteId, img, { pixelRatio: 2 });
          }
        } catch (e) {}
      }

      /******************************************************************
       * initMap
       * - Mapbox Map 생성
       * - load: 최초 스타일 로드 완료 시
       * - style.load: 스타일 변경(setStyle) 후 로드 완료 시
       *
       * 주의: setStyle을 호출하면 "layer/source/image"가 초기화되므로
       *       style.load에서 다시 setupSourcesAndLayers/ensureFallbackSprite가 필요함
       ******************************************************************/
      function initMap(styleUrl="mapbox://styles/mapbox/dark-v11"){
        showMapLoading(t("load.mapLoading"));

        map = new mapboxgl.Map({
          container: "map",
          style: styleUrl,
          center: [126.978, 37.5665],
          zoom: 11,
          attributionControl: false,
        });

        // Mapbox 내부 오류 로깅 + 사용자 메시지
        map.on("error", (e)=>{
          console.error("[MAPBOX ERROR]", e.error);
          setStatus("지도를 불러오지 못했습니다. 잠시 후 다시 시도해 주세요.");
        });

        // icon-image가 없는 경우, 여기서 동적으로 addImage를 시도
        map.on("styleimagemissing", (e) => {
          const id = e.id;
          if (!id) return;

          if (id === FALLBACK_SPRITE_ID) {
            try { ensureFallbackSprite(); } catch {}
            return;
          }

          if (typeof id === "string" && id.startsWith("thumb-")) {
            const photoId = id.slice("thumb-".length);
            ensureOneThumbSpriteById(photoId);
          }
        });

        // 최초 로드 완료
        map.on("load", () => {
          ensureFallbackSprite();
          setupSourcesAndLayers();
          isMapReady = true;

          // 초기 메시지/버튼 상태
          setStatus(t("load.mapReady"));
          btnLoad.disabled = true;
          btnLoad.textContent = t("load.btnNeedFolder");

          hideMapLoading();

          // density 기본 레벨 세팅 (경계 로딩 + choropleth)
          setLevel(currentLevel);

          // 만약 lastPhotos가 이미 존재한다면 지도 복원(리로드 시)
          if (lastPhotos.length > 0) {
            updateMapData(lastPhotos);
            refreshChoroplethWithFilteredPoints(getCurrentPhotoPoints());
          }

          applyMapMode();
        });

        // setStyle 이후에도 동일 로직 재적용
        map.on("style.load", () => {
          ensureFallbackSprite();
          setupSourcesAndLayers();

          setLevel(currentLevel);

          if (lastPhotos.length > 0) {
            updateMapData(lastPhotos);
            refreshChoroplethWithFilteredPoints(getCurrentPhotoPoints());
          }

          ensureThumbSprites((lastPhotos && lastPhotos.length) ? lastPhotos : allPhotos);
          applyMapMode();
        });
      }

      /******************************************************************
       * setupSourcesAndLayers
       * - Mapbox source/layer를 "id 존재 여부"로 안전하게 upsert
       * - 스타일 변경 시에도 다시 호출 가능하도록 설계
       ******************************************************************/
      function setupSourcesAndLayers(){
        // Raw photo points (glow/core용)
        if (!map.getSource("photos")) {
          map.addSource("photos", { type: "geojson", data: { type: "FeatureCollection", features: [] } });
        }

        // Cluster source (thumb/cluster용)
        if (!map.getSource("photos-cluster")) {
          map.addSource("photos-cluster", {
            type: "geojson",
            data: { type: "FeatureCollection", features: [] },
            cluster: true,
            clusterMaxZoom: 14,
            clusterRadius: 48
          });
        }

        // Glow layer: 큰 circle + blur
        if (!map.getLayer("photos-glow")) {
          map.addLayer({
            id: "photos-glow",
            type: "circle",
            source: "photos",
            paint: {
              "circle-radius": ["interpolate", ["linear"], ["zoom"], 10, 24, 14, 72],
              "circle-color": ["get","color"],
              "circle-opacity": 0.35,
              "circle-blur": 0.25,
            },
          });
        }

        // Core layer: 작은 점 (Glow 모드에서 상세 포인트)
        if (!map.getLayer("photos-core")) {
          map.addLayer({
            id: "photos-core",
            type: "circle",
            source: "photos",
            paint: {
              "circle-radius": ["interpolate", ["linear"], ["zoom"], 12, 3, 14, 8],
              "circle-color": ["get","color"],
              // zoom에 따라 점이 서서히 나타나도록 opacity 보간
              "circle-opacity": ["interpolate", ["exponential",1.5], ["zoom"], 0,0, 11.5,0, 12.0,0.25, 13.0,0.7, 14.0,1.0],
              "circle-stroke-color": "#fff",
              "circle-stroke-width": 0.5,
            },
          });
        }

        // Cluster circles
        if (!map.getLayer("clusters")) {
          map.addLayer({
            id: "clusters",
            type: "circle",
            source: "photos-cluster",
            filter: ["has", "point_count"],
            paint: {
              // 개수 구간별 색상(step)
              "circle-color": ["step", ["get", "point_count"], "#60a5fa", 10, "#34d399", 30, "#f59e0b", 100, "#ef4444"],
              "circle-radius": ["step", ["get", "point_count"], 16, 10, 20, 30, 26, 100, 32],
              "circle-opacity": 0.9
            }
          });
        }

        // Cluster count label
        if (!map.getLayer("cluster-count")) {
          map.addLayer({
            id: "cluster-count",
            type: "symbol",
            source: "photos-cluster",
            filter: ["has", "point_count"],
            layout: {
              "text-field": ["get", "point_count_abbreviated"],
              "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
              "text-size": 12
            },
            paint: { "text-color": "#0f172a" }
          });
        }

        // Unclustered thumb sprite
        if (!map.getLayer("unclustered-thumb")) {
          map.addLayer({
            id: "unclustered-thumb",
            type: "symbol",
            source: "photos-cluster",
            filter: ["!", ["has", "point_count"]],
            layout: {
              // imgId(sprite)가 있으면 사용, 없으면 fallback
              "icon-image": ["coalesce", ["get", "imgId"], FALLBACK_SPRITE_ID],
              "icon-size": ["interpolate", ["linear"], ["zoom"], 4, 0.25, 10, 0.5, 14, 0.7, 16, 0.9],
              "icon-allow-overlap": true,
              "icon-ignore-placement": true
            }
          });
        }

        /******************************************************************
         * CLICK HANDLERS
         * - 중복 바인딩 방지(photosCoreClickBound)
         ******************************************************************/
        if (!photosCoreClickBound) {
          map.on("click", "photos-core", handlePointPopup);
          map.on("click", "unclustered-thumb", handlePointPopup);

          // cluster 클릭 시 확대
          map.on("click", "clusters", (e) => {
            const features = map.queryRenderedFeatures(e.point, { layers: ["clusters"] });
            const clusterId = features[0].properties.cluster_id;
            map.getSource("photos-cluster").getClusterExpansionZoom(clusterId, (err, zoom) => {
              if (err) return;
              map.easeTo({ center: features[0].geometry.coordinates, zoom });
            });
          });

          photosCoreClickBound = true;
        }
      }

      /******************************************************************
       * handlePointPopup
       * - 포인트 클릭 시 팝업 구성
       * - 이미지: 즉시 placeholder 출력 → async로 썸네일 로드 후 교체
       * - 날씨: 촬영 시간 파싱 → Open-Meteo 호출(캐시 적용) → 결과 렌더
       ******************************************************************/
      async function handlePointPopup(e){
        const f = e.features && e.features[0];
        if (!f) return;

        const p = f.properties || {};
        const title = p.label || "(사진)";
        const time  = p.time || "";
        const lngLat = f.geometry.coordinates;

        // 팝업 내부 DOM을 고유 id로 분리 (동시 팝업 여러 개 대응)
        const popupId = "pmePopup_" + Math.random().toString(36).slice(2);
        const imgBoxId = `${popupId}_img`;
        const weatherId = `${popupId}_weather`;

        const popup = new mapboxgl.Popup({ closeButton:false, maxWidth:"300px" })
          .setLngLat(lngLat)
          .setHTML(`
            <div id="${popupId}">
              <div style="font-weight:600;margin-bottom:6px">${title}</div>

              <div id="${imgBoxId}" style="border-radius:10px; overflow:hidden; background:rgba(255,255,255,.06);">
                <div style="padding:10px; font-size:12px; opacity:.85;">
                  ${t("popup.photoLoading")}
                </div>
              </div>

              ${time ? `<div style="margin-top:6px;font-size:12px;opacity:.8">${time}</div>` : ""}

              <div id="${weatherId}" style="margin-top:8px;font-size:12px;opacity:.9">
                ${t("popup.weatherLoading")}
              </div>
            </div>
          `)
          .addTo(map);

        // 1) 이미지 로딩
        try {
          let imgUrl = p.img || "";
          // properties에 img가 없으면 thumb 캐시/생성으로 확보
          if (!imgUrl && p.photoId) {
            const ph = (lastPhotos || allPhotos).find(x => x.id === p.photoId);
            if (ph) imgUrl = await getThumbObjectUrl(ph);
          }

          const root = popup.getElement();
          const imgBox = root && root.querySelector(`#${imgBoxId}`);

          if (imgBox) {
            if (imgUrl) {
              imgBox.innerHTML = `
                <img src="${imgUrl}"
                     style="width:100%; border-radius:10px; display:block;"
                     loading="lazy"
                />
              `;
            } else {
              imgBox.innerHTML = `
                <div style="padding:10px; font-size:12px; opacity:.78;">
                  ${t("popup.photoUnavailable")}
                </div>
              `;
            }
          }
        } catch (err) {
          const root = popup.getElement();
          const imgBox = root && root.querySelector(`#${imgBoxId}`);
          if (imgBox) {
            imgBox.innerHTML = `
              <div style="padding:10px; font-size:12px; opacity:.78;">
                ${t("popup.photoFail")}
              </div>
            `;
          }
        }

        // 2) 날씨 로딩
        try{
          const d = parsePhotoDate(time);
          const root = popup.getElement();
          const el = root && root.querySelector(`#${weatherId}`);

          if (!d) {
            if (el) el.textContent = t("popup.weatherNoDate");
            return;
          }

          const dateStr = ymdLocal(d);
          const lat = Number(lngLat[1]);
          const lon = Number(lngLat[0]);

          const w = await getWeatherCached(lat, lon, dateStr);
          if (!el) return;

          if (!w) {
            el.textContent = t("popup.weatherUnavailable");
            return;
          }

          const tempTxt = (w.temp == null) ? "—" : `${Number(w.temp).toFixed(1)}°C`;
          const rainTxt = (w.rain == null) ? "—" : `${Number(w.rain).toFixed(1)}mm`;
          const descTxt = weatherCodeToKorean(w.code);

          el.innerHTML = `
            <div style="font-weight:600;margin-bottom:4px;">${t("popup.weatherTitle")}</div>
            <div>${t("popup.temp")}: <b>${tempTxt}</b></div>
            <div>${t("popup.weather")}: <b>${descTxt}</b></div>
            <div>${t("popup.rain")}: <b>${rainTxt}</b></div>
            <div style="opacity:.7;margin-top:4px;">(${t("popup.openMeteo",{dateStr})})</div>
          `;
        } catch(err){
          const root = popup.getElement();
          const el = root && root.querySelector(`#${weatherId}`);
          if (el) el.textContent = t("popup.weatherFail");
        }
      }

      // 맵 초기화(최초 1회)
      initMap();

      /******************************************************************
       * Mapbox loadImage wrapper
       * - map.loadImage는 callback 기반이라 Promise로 감싸 사용성 개선
       ******************************************************************/
      function loadImageAsync(url){
        return new Promise((resolve, reject)=>{
          map.loadImage(url, (err, image)=>{ if (err) reject(err); else resolve(image); });
        });
      }

      /******************************************************************
       * ensureThumbSprites
       * - 현재 photos 배열의 썸네일 sprite를 제한된 동시성으로 addImage
       * - style.load 이후 sprite가 날아가므로, 재호출이 필요할 수 있음
       ******************************************************************/
      async function ensureThumbSprites(photos){
        if (!map) return;
        if (!driveAccessToken) return;

        await mapLimit(photos, 6, async (p)=>{
          const spriteId = `thumb-${p.id}`;
          if (map.hasImage(spriteId)) return;

          try{
            const objUrl = await getThumbObjectUrl(p);
            const img = await loadImageAsync(objUrl);
            if (!map.hasImage(spriteId)) {
              map.addImage(spriteId, img, { pixelRatio: 2 });
            }
          } catch (e) {}
        });
      }

      /******************************************************************
       * updateMapData
       * - photos(필터된 결과)를 기준으로:
       *   1) photos source (glow/core)
       *   2) photos-cluster source (cluster/thumb)
       *   를 업데이트한다.
       *
       * - thumb sprite는 비동기로 추가되므로:
       *   ensureThumbSprites 후 다시 photos source를 setData하여
       *   popup에서 imgUrl을 참조할 때 최신 캐시를 반영하도록 처리
       ******************************************************************/
      function updateMapData(photos){
        lastPhotos = photos;

        // glow/core 용 feature collection
        const fc = {
          type: "FeatureCollection",
          features: photos.map((p)=>({
            type: "Feature",
            geometry: { type: "Point", coordinates: [p.lon, p.lat] },
            properties: {
              id: p.id,
              color: pickColorForPhoto(p),
              img: thumbObjectUrlByPhotoId.get(p.id) || "",
              label: p.name,
              time: p.time || "",
              photoId: p.id
            }
          }))
        };
        const src = map.getSource("photos"); if (src) src.setData(fc);

        // cluster/thumb 용 feature collection
        const fcCluster = {
          type: "FeatureCollection",
          features: photos.map((p)=>({
            type: "Feature",
            geometry: { type: "Point", coordinates: [p.lon, p.lat] },
            properties: {
              color: pickColorForPhoto(p),
              imgId: `thumb-${p.id}`,
              img: thumbObjectUrlByPhotoId.get(p.id) || "",
              label: p.name || "",
              time: p.time || "",
              photoId: p.id
            }
          }))
        };
        const src2 = map.getSource("photos-cluster"); if (src2) src2.setData(fcCluster);

        // sprite 생성 후, photos source도 한번 더 갱신(팝업 img URL 최신화 목적)
        ensureThumbSprites(photos).then(()=>{
          const fc2 = {
            type: "FeatureCollection",
            features: photos.map((p)=>({
              type: "Feature",
              geometry: { type: "Point", coordinates: [p.lon, p.lat] },
              properties: {
                id: p.id,
                color: pickColorForPhoto(p),
                img: thumbObjectUrlByPhotoId.get(p.id) || "",
                label: p.name,
                time: p.time || "",
                photoId: p.id
              }
            }))
          };
          const s = map.getSource("photos"); if (s) s.setData(fc2);
        });

        // density 모드라면 choropleth도 즉시 재계산
        if (currentMapMode === "density") {
          refreshChoroplethWithFilteredPoints(getCurrentPhotoPoints());
        }
      }

      /******************************************************************
       * renderPhotoList
       * - 사이드바 목록 렌더
       * - 각 항목: 클릭 시 map.flyTo + active highlight
       * - 썸네일은 async로 로딩하며 spinner를 사용
       ******************************************************************/
      function renderPhotoList(photos){
        photoListEl.innerHTML = "";
        const textColor = currentTheme === "dark" ? "#ffffff" : "#0f172a";

        photos.forEach((p)=>{
          const c = pickColorForPhoto(p);
          const div = document.createElement("div");
          div.className = "photo-item"; div.dataset.id = p.id;

          // 다크/라이트 테마에서 목록 강조 방식 다르게
          if (currentTheme === "dark") { div.style.borderLeft = "4px solid rgba(255,255,255,.03)"; div.style.background = "#141414"; }
          else { div.style.borderLeft = `4px solid ${c}`; div.style.background = "#ffffff"; }

          div.innerHTML = `
            <div class="thumb-wrap" data-thumbwrap="${p.id}">
              <div class="thumb-spinner">
                <div class="orbital-spinner small" aria-label="loading">
                  <span class="dot"></span><span class="dot"></span><span class="dot"></span><span class="dot"></span>
                  <span class="dot"></span><span class="dot"></span><span class="dot"></span><span class="dot"></span>
                </div>
              </div>
              <img data-pid="${p.id}" src="" style="background:${c}" />
            </div>
            <div style="flex:1;word-break:break-all;font-size:.85rem;color:${textColor};">
              <div style="line-height:1.2;">${p.name}</div>
            </div>
          `;

          // 목록 클릭: 지도 이동 + 선택 강조
          div.addEventListener("click", ()=>{
            selectedPhotoId = p.id; highlightPhotoInList(p.id);
            map.flyTo({ center:[p.lon,p.lat], zoom: 15, duration: 1200 });
          });

          photoListEl.appendChild(div);

          // 썸네일 비동기 로드
          (async ()=>{
            try{
              const url = await getThumbObjectUrl(p);
              const imgEl = div.querySelector(`img[data-pid="${p.id}"]`);
              const wrap = div.querySelector(`.thumb-wrap[data-thumbwrap="${p.id}"]`);

              if (imgEl) {
                imgEl.onload = () => { if (wrap) wrap.classList.add("loaded"); };
                imgEl.onerror = () => { if (wrap) wrap.classList.add("loaded"); };
                imgEl.src = url;
              } else {
                if (wrap) wrap.classList.add("loaded");
              }
            } catch(e){
              const wrap = div.querySelector(`.thumb-wrap[data-thumbwrap="${p.id}"]`);
              if (wrap) wrap.classList.add("loaded");
            }
          })();
        });
      }

      function highlightPhotoInList(id){
        Array.from(photoListEl.children).forEach(el => {
          el.classList.toggle("active", el.dataset.id === id);
        });
      }

      /******************************************************************
       * getDriveToken (Google Identity Services)
       * - OAuth access token 발급
       *
       * scope 주의:
       * - 현재: drive.file (앱이 만든/열어준 파일에 접근)
       * - 만약 "사용자 전체 드라이브 읽기"가 필요하면 drive.readonly 등 변경 필요
       ******************************************************************/
      async function getDriveToken(){
        if (!window.google || !window.google.accounts || !window.google.accounts.oauth2) {
          throw new Error(t("auth.tokenNotReady"));
        }
        return new Promise((resolve, reject)=>{
          const client = window.google.accounts.oauth2.initTokenClient({
            client_id: GOOGLE_CLIENT_ID,
            scope: "https://www.googleapis.com/auth/drive.file",
            callback: (resp)=>{
              if (resp && resp.access_token) {
                saveToken(resp.access_token, resp.expires_in || 3600);
                resolve(resp.access_token);
              } else {
                reject(new Error("Google 연결 정보를 받지 못했습니다."));
              }
            },
          });
          client.requestAccessToken();
        });
      }

      /******************************************************************
       * LOGIN BUTTON FLOW
       * - 로딩 모달 + 상태 문구를 통해 사용자에게 진행 상황을 명확히 보여준다
       ******************************************************************/
      btnLogin.addEventListener("click", async ()=>{
        try {
          setStatus(t("auth.connectProgressStatus"));
          showAppLoading(t("auth.connectModalTitle"), t("auth.connectModalSub"));
          driveAccessToken = await getDriveToken();
          hideAppLoading();

          setStatus(t("auth.done"));
          applyLoggedInUI();
        } catch (err) {
          console.error(err);
          hideAppLoading();
          setStatus(t("auth.connectFail"));
        }
      });

      /******************************************************************
       * TOKEN BOOTSTRAP
       * - 새로고침해도 토큰이 유효하면 로그인 상태를 복원
       ******************************************************************/
      (function bootstrapTokenFromStorage(){
        const token = loadStoredToken();
        if (token) {
          driveAccessToken = token;
          setStatus(t("auth.restoredToken"));
          applyLoggedInUI();
        } else {
          clearStoredToken();
        }
      })();

      /******************************************************************
       * Picker API 로드
       * - gapi.load("picker")는 callback 기반
       ******************************************************************/
      function loadPickerApi(){
        return new Promise((resolve, reject)=>{
          if (!window.gapi) return reject(new Error(t("auth.pickerNotReady")));
          gapi.load("picker", { callback: resolve });
        });
      }

      /******************************************************************
       * openFolderPicker
       * - Google Picker로 폴더 선택
       * - 선택 시 selectedFolderId/name 설정, Load 버튼 활성화
       ******************************************************************/
      async function openFolderPicker(){
        if (!driveAccessToken) {
          setStatus(t("auth.needConnect"));
          return;
        }

        await loadPickerApi();

        const view = new google.picker.DocsView(google.picker.ViewId.FOLDERS)
          .setIncludeFolders(true)
          .setSelectFolderEnabled(true);

        const picker = new google.picker.PickerBuilder()
          .setDeveloperKey(GOOGLE_API_KEY)
          .setOAuthToken(driveAccessToken)
          .addView(view)
          .setTitle(t("folder.pickerTitle"))
          .setCallback((data)=>{
            if (data.action === google.picker.Action.PICKED) {
              const doc = data.docs[0];
              selectedFolderId = doc.id;
              selectedFolderName = doc.name || "(이름 없음)";
              cacheFileName = getCacheFileNameByFolderId(selectedFolderId);

              pickedFolderLabel.textContent = t("folder.picked", { name: selectedFolderName });
              setStatus(t("folder.pickedStatus"));

              btnLoad.disabled = false;
              btnLoad.textContent = t("load.btnLoad");
            }
            if (data.action === google.picker.Action.CANCEL) {
              setStatus(t("folder.cancelled"));
            }
          })
          .build();

        picker.setVisible(true);
      }

      /******************************************************************
       * PICK FOLDER BUTTON FLOW
       ******************************************************************/
      btnPickFolder.addEventListener("click", async ()=>{
        try {
          setStatus(t("folder.pickReadyStatus"));
          showAppLoading(t("folder.pickReadyModalTitle"), t("folder.pickReadyModalSub"));
          await openFolderPicker();
          hideAppLoading();
        } catch (e) {
          console.error(e);
          hideAppLoading();
          setStatus(t("folder.pickFail"));
        }
      });

      /******************************************************************
       * listDrivePhotos
       * - 폴더 내 image/* 목록을 페이징으로 가져오고
       * - GPS가 있는 것만 추출하여 Photo 객체로 반환
       ******************************************************************/
      async function listDrivePhotos(accessToken, folderId){
        const out = []; let pageToken;
        while (true) {
          const params = new URLSearchParams({
            q: `'${folderId}' in parents and mimeType contains 'image/' and trashed=false`,
            fields: "files(id,name,thumbnailLink,createdTime,imageMediaMetadata(location,time,cameraMake,cameraModel)),nextPageToken",
            pageSize: "1000",
          });
          if (pageToken) params.set("pageToken", pageToken);

          const res = await fetch("https://www.googleapis.com/drive/v3/files?" + params.toString(),
            { headers: { Authorization: `Bearer ${accessToken}` } }
          );

          if (res.status === 401) {
            clearStoredToken();
            driveAccessToken = null;
            btnLogin.disabled = false;
            btnPickFolder.disabled = true;
            btnLoad.disabled = true;
            btnLoad.textContent = t("load.btnNeedFolder");
            throw new Error(t("auth.expired"));
          }

          if (!res.ok) {
            const tt = await res.text().catch(()=> "");
            console.error("Drive list error:", res.status, tt);
            throw new Error("Drive 목록을 불러오지 못했습니다.");
          }
          const data = await res.json();

          for (const f of data.files ?? []) {
            const loc = f.imageMediaMetadata?.location;
            if (loc?.latitude && loc?.longitude) {
              out.push({
                id: f.id,
                name: f.name,
                thumb: f.thumbnailLink, // Drive가 제공하는 thumbnailLink (CORS/권한 때문에 실제로는 쓰기 어려울 때가 많음)
                time: f.imageMediaMetadata?.time ?? f.createdTime,
                lat: loc.latitude,
                lon: loc.longitude,
              });
            }
          }
          pageToken = data.nextPageToken; if (!pageToken) break;
        }
        return out;
      }

      /******************************************************************
       * DRIVE CACHE JSON 관리
       * - 폴더 내부에 `${folderId}.json`을 저장/갱신
       * - 목적: 다음 실행 시 대표색 분석 등을 스킵하여 성능 향상
       ******************************************************************/
      async function findCacheJsonFileId(accessToken, folderId, fileName){
        const q = [
          `'${folderId}' in parents`,
          `name='${fileName.replace(/'/g, "\\'")}'`,
          `mimeType='application/json'`,
          `trashed=false`
        ].join(" and ");

        const params = new URLSearchParams({
          q,
          fields: "files(id,name,modifiedTime,createdTime)",
          pageSize: "10",
        });

        const res = await fetch("https://www.googleapis.com/drive/v3/files?" + params.toString(), {
          headers: { Authorization: `Bearer ${accessToken}` }
        });

        if (res.status === 401) {
          clearStoredToken();
          driveAccessToken = null;
          btnLogin.disabled = false;
          btnPickFolder.disabled = true;
          btnLoad.disabled = true;
          btnLoad.textContent = t("load.btnNeedFolder");
          throw new Error(t("auth.expired"));
        }

        if (!res.ok) throw new Error("캐시 파일을 확인할 수 없습니다.");

        const data = await res.json();
        const files = data.files || [];
        if (files.length === 0) return null;

        // 최신 수정 파일 우선
        files.sort((a,b)=> new Date(b.modifiedTime || b.createdTime) - new Date(a.modifiedTime || a.createdTime));
        return files[0].id;
      }

      async function downloadJsonFile(accessToken, fileId){
        const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
          headers: { Authorization: `Bearer ${accessToken}` }
        });

        if (res.status === 401) {
          clearStoredToken();
          driveAccessToken = null;
          btnLogin.disabled = false;
          btnPickFolder.disabled = true;
          btnLoad.disabled = true;
          btnLoad.textContent = t("load.btnNeedFolder");
          throw new Error(t("auth.expired"));
        }

        if (!res.ok) throw new Error("캐시를 불러오지 못했습니다.");
        return await res.json();
      }

      // multipart upload로 JSON 파일 생성
      async function createJsonFileInFolder(accessToken, folderId, fileName, jsonObj){
        const boundary = "-------pmeBoundary" + Math.random().toString(16).slice(2);
        const metadata = { name: fileName, mimeType: "application/json", parents: [folderId] };

        const body =
`--${boundary}
Content-Type: application/json; charset=UTF-8

${JSON.stringify(metadata)}
--${boundary}
Content-Type: application/json; charset=UTF-8

${JSON.stringify(jsonObj)}
--${boundary}--`;

        const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": `multipart/related; boundary=${boundary}`,
          },
          body
        });

        if (res.status === 401) {
          clearStoredToken();
          driveAccessToken = null;
          btnLogin.disabled = false;
          btnPickFolder.disabled = true;
          btnLoad.disabled = true;
          btnLoad.textContent = t("load.btnNeedFolder");
          throw new Error(t("auth.expired"));
        }

        if (!res.ok) {
          const tt = await res.text().catch(()=> "");
          throw new Error("캐시를 저장하지 못했습니다: " + res.status + " " + tt);
        }

        return await res.json();
      }

      // multipart PATCH로 JSON 파일 갱신
      async function updateJsonFileContent(accessToken, fileId, fileName, jsonObj){
        const boundary = "-------pmeBoundary" + Math.random().toString(16).slice(2);
        const metadata = { name: fileName, mimeType: "application/json" };

        const body =
`--${boundary}
Content-Type: application/json; charset=UTF-8

${JSON.stringify(metadata)}
--${boundary}
Content-Type: application/json; charset=UTF-8

${JSON.stringify(jsonObj)}
--${boundary}--`;

        const res = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, {
          method: "PATCH",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": `multipart/related; boundary=${boundary}`,
          },
          body
        });

        if (res.status === 401) {
          clearStoredToken();
          driveAccessToken = null;
          btnLogin.disabled = false;
          btnPickFolder.disabled = true;
          btnLoad.disabled = true;
          btnLoad.textContent = t("load.btnNeedFolder");
          throw new Error(t("auth.expired"));
        }

        if (!res.ok) {
          const tt = await res.text().catch(()=> "");
          throw new Error("캐시를 갱신하지 못했습니다: " + res.status + " " + tt);
        }

        return await res.json();
      }

      /******************************************************************
       * tryLoadFromCacheOrNull
       * - cache 존재하면 가져오되:
       *   - folderId 매칭 확인
       *   - photos 배열 유효성 확인
       ******************************************************************/
      async function tryLoadFromCacheOrNull(){
        if (!driveAccessToken || !selectedFolderId || !cacheFileName) return null;

        const cacheId = await findCacheJsonFileId(driveAccessToken, selectedFolderId, cacheFileName);
        if (!cacheId) return null;

        const cache = await downloadJsonFile(driveAccessToken, cacheId);
        if (cache?.folder?.id && cache.folder.id !== selectedFolderId) return null;
        if (!Array.isArray(cache?.photos)) return null;
        return { cache, cacheId };
      }

      /******************************************************************
       * LOAD 버튼: 전체 파이프라인
       * 1) 캐시 존재/버전 확인
       * 2) 폴더 변경 여부 해시로 확인
       * 3) 변경 없으면 캐시 재사용
       * 4) 변경 있으면 Drive 재조회 → 대표색 분석 → 맵 반영 → 캐시 저장/갱신
       ******************************************************************/
      btnLoad.addEventListener("click", async ()=>{
        if (!isMapReady){ setStatus(t("load.mapNotReady")); return; }
        const folderId = selectedFolderId;
        if (!folderId){ setStatus(t("load.needFolder")); return; }
        if (!driveAccessToken){ setStatus(t("auth.needConnect")); return; }

        if (!cacheFileName) cacheFileName = getCacheFileNameByFolderId(selectedFolderId);

        btnLoad.disabled = true;
        showAppLoading(t("load.appLoadingTitleDefault"), t("load.flowSub"));

        try {
          setStatus(t("load.checkingCache"));
          const cachedPack = await tryLoadFromCacheOrNull();

          let cacheId = null;
          let cache = null;
          if (cachedPack) {
            cache = cachedPack.cache;
            cacheId = cachedPack.cacheId;
          }

          // schemaVersion 또는 photoIdHash 유무로 "구버전 캐시" 판단
          const isOldCache = !!(cache && (cache.schemaVersion !== CACHE_SCHEMA_VERSION || !cache.photoIdHash));
          if (cache && isOldCache) {
            setStatus(t("load.oldCache"));
          }

          // 폴더 상태(변경 여부) 확인
          setStatus(t("load.checkingFolder"));
          showAppLoading(t("load.checkingFolderModalTitle"), t("load.checkingFolderModalSub"));
          const currentSig = await computePhotoIdHashFromFolder(driveAccessToken, folderId);

          // 캐시 재사용 가능: 해시 동일 + 스키마 최신
          if (cache && !isOldCache && cache.photoIdHash === currentSig.hash) {
            setStatus(t("load.reuseCache"));
            allPhotos = cache.photos.slice();

            showAppLoading(t("load.applyModalTitle"), t("load.applyModalSub"));
            updateMapData(allPhotos);
            renderPhotoList(allPhotos);
            buildTimeline(allPhotos);

            // 전체 영역 fitBounds
            const bounds = new mapboxgl.LngLatBounds();
            allPhotos.forEach(p => bounds.extend([p.lon, p.lat]));
            map.fitBounds(bounds, { padding: 80, duration: 1200 });
            return;
          }

          // 캐시 미사용: 변경/최초/구버전 등
          if (cache && !isOldCache && cache.photoIdHash !== currentSig.hash) {
            setStatus(t("load.changed", { count: currentSig.count }));
          } else if (!cache) {
            setStatus(t("load.firstTime", { count: currentSig.count }));
          } else {
            setStatus(t("load.refresh", { count: currentSig.count }));
          }

          // Drive에서 실제 파일 목록 조회
          showAppLoading(t("load.listModalTitle"), t("load.listModalSub"));
          const files = await listDrivePhotos(driveAccessToken, folderId);
          if (files.length === 0) {
            setStatus(t("load.noGeoPhotos"));
            return;
          }

          // 대표색 분석 진행(동시성 제한)
          setStatus(t("load.foundPhotos", { count: files.length }));
          showAppLoading(t("load.analyzeModalTitle"), t("load.analyzeModalSub", { count: files.length }));
          let done = 0;

          const processed = await mapLimit(files, 3, async (f, idx)=>{
            // 팔레트 색은 즉시 할당(fallback)
            const paletteColor = FIREWORK_PALETTE[idx % FIREWORK_PALETTE.length];
            let dominantColor = null;

            try {
              // NOTE: 아래 함수는 "프로젝트 외부/다른 파일"에 정의되어 있어야 정상 동작
              dominantColor = await getDominantColorFromDrive_LabKMeans(f.id, driveAccessToken, {
                maxSize: 200,
                sampleStep: 2,
                k: 6,
                maxIter: 20,
                trials: 5
              });
            } catch(e){}

            done++;
            // UI 업데이트는 너무 잦으면 성능/UX에 악영향이므로 간격 조절
            if (done % 5 === 0 || done === files.length) {
              setStatus(t("load.analyzingProgress", { done, total: files.length }));
              showAppLoading(t("load.analyzeModalTitle"), t("load.analyzeModalProgressSub", { done, total: files.length }));
            }

            return { ...f, dominantColor, paletteColor };
          });

          allPhotos = processed.slice();

          // 지도/목록/타임라인 반영
          showAppLoading(t("load.applyModalTitle"), t("load.applyModalSub"));
          updateMapData(processed);
          renderPhotoList(processed);
          buildTimeline(allPhotos);

          const bounds = new mapboxgl.LngLatBounds();
          processed.forEach(p => bounds.extend([p.lon, p.lat]));
          map.fitBounds(bounds, { padding: 80, duration: 1200 });

          // 캐시 저장 객체 구성
          const cacheObj = {
            schemaVersion: CACHE_SCHEMA_VERSION,
            folder: { id: selectedFolderId, name: selectedFolderName },
            generatedAt: new Date().toISOString(),
            photoCount: allPhotos.length,
            photoIdHash: currentSig.hash,
            photos: allPhotos
          };

          setStatus(t("load.saving"));
          showAppLoading(t("load.savingModalTitle"), t("load.savingModalSub"));

          if (cacheId) {
            await updateJsonFileContent(driveAccessToken, cacheId, cacheFileName, cacheObj);
          } else {
            await createJsonFileInFolder(driveAccessToken, selectedFolderId, cacheFileName, cacheObj);
          }

          setStatus(t("load.doneSaved"));

        } catch (err) {
          console.error(err);
          setStatus(t("load.errRefresh"));
        } finally {
          hideAppLoading();
          btnLoad.disabled = false;
          btnLoad.textContent = t("load.btnLoad");
        }
      });

      /******************************************************************
       * TIMELINE: 월 단위 버킷 생성
       * - 사진의 time 파싱 → yyyy-mm로 집계 → range 슬라이더에 반영
       ******************************************************************/
      function buildTimeline(photos){
        const bucket = new Map();
        photos.forEach(p=>{
          const d = parsePhotoDate(p.time); if (!d) return;
          const y=d.getFullYear(), m=d.getMonth()+1, key=`${y}-${String(m).padStart(2,"0")}`;
          if (!bucket.has(key)) bucket.set(key, {year:y, month:m, count:0});
          bucket.get(key).count++;
        });

        const months = Array.from(bucket.values())
          .filter(it=>it.count>0)
          .sort((a,b)=> a.year===b.year ? a.month-b.month : a.year-b.year)
          .map((it,idx)=>({...it, index:idx, label:t("timeline.label",{y:it.year,m:it.month,count:it.count})}));

        if (months.length===0){
          timelineMonths=[];
          timelineRange.min=0; timelineRange.max=0; timelineRange.value=0; timelineRange.disabled=true;
          timelineLabel.textContent=t("timeline.noDate");
          return;
        }

        // value === months.length 는 "전체 보기"로 해석
        timelineMonths = months;
        timelineRange.disabled=false;
        timelineRange.min=0;
        timelineRange.max=months.length;
        timelineRange.value=months.length;
        timelineLabel.textContent=t("timeline.all");
        currentTimelineIndex = -1;
      }

      /******************************************************************
       * applyTimelineFilter
       * - index === -1: 전체
       * - 그 외: 해당 yyyy/mm만 필터링해서 updateMapData + renderPhotoList
       ******************************************************************/
      function applyTimelineFilter(index){
        if (index===-1 || index>=timelineMonths.length){
          updateMapData(allPhotos);
          renderPhotoList(allPhotos);
          timelineLabel.textContent=t("timeline.all");

          if (allPhotos.length>0 && map){
            const b = new mapboxgl.LngLatBounds();
            allPhotos.forEach(p=>b.extend([p.lon,p.lat]));
            map.fitBounds(b, { padding: 80, duration: 800 });
          }
          return;
        }

        const target = timelineMonths[index];
        const filtered = allPhotos.filter(p=>{
          const d = parsePhotoDate(p.time); if (!d) return false;
          return d.getFullYear()===target.year && (d.getMonth()+1)===target.month;
        });

        updateMapData(filtered);
        renderPhotoList(filtered);
        timelineLabel.textContent = target.label;

        if (filtered.length>0 && map){
          const b = new mapboxgl.LngLatBounds();
          filtered.forEach(p=>b.extend([p.lon,p.lat]));
          map.fitBounds(b, { padding: 80, duration: 800 });
        }
      }

      // 타임라인 슬라이더 입력 처리
      if (timelineRange){
        timelineRange.addEventListener("input", (e)=>{
          const v = Number(e.target.value);
          if (timelineMonths.length===0) return;

          // max 값(=months.length)이면 전체 보기
          if (v>=timelineMonths.length){ currentTimelineIndex=-1; applyTimelineFilter(-1); }
          else { currentTimelineIndex=v; applyTimelineFilter(v); }
        });
      }

      /******************************************************************
       * COLOR MODE CHANGE
       * - 색상 모드가 바뀌면 현재 필터 상태를 유지한 채로 재렌더링
       ******************************************************************/
      colorModeSelect.addEventListener("change", ()=>{
        currentColorMode = colorModeSelect.value;
        if (currentTimelineIndex===-1){ updateMapData(allPhotos); renderPhotoList(allPhotos); }
        else { applyTimelineFilter(currentTimelineIndex); }
      });

      /******************************************************************
       * RESET (로그아웃)
       * - 토큰 자체는 여기서 지우지 않음(현재 구현은 "앱 상태 초기화" 중심)
       * - 필요하면 clearStoredToken()까지 호출하여 완전 로그아웃을 구현 가능
       ******************************************************************/
      btnReset.addEventListener("click", ()=>{
        photoListEl.innerHTML = ""; selectedPhotoId = null;
        allPhotos = []; lastPhotos = []; timelineMonths = []; currentTimelineIndex = -1;

        selectedFolderId = null;
        selectedFolderName = null;
        cacheFileName = null;
        pickedFolderLabel.textContent = t("folder.pickedNone");

        clearThumbObjectUrls();

        // 맵 데이터 비우기
        if (map && map.getSource("photos")) {
          map.getSource("photos").setData({ type:"FeatureCollection", features:[] });
          map.flyTo({ center:[126.978,37.5665], zoom: 11 });
        }
        if (map && map.getSource("photos-cluster")) {
          map.getSource("photos-cluster").setData({ type:"FeatureCollection", features:[] });
        }

        // 타임라인 초기화
        timelineRange.min=0; timelineRange.max=0; timelineRange.value=0; timelineRange.disabled=true;
        timelineLabel.textContent=t("timeline.noDate");

        // Load 버튼 비활성
        btnLoad.disabled = true;
        btnLoad.textContent = t("load.btnNeedFolder");

        // density 팔레트 팝 닫기
        if (densityPalettePop) densityPalettePop.style.display = "none";

        setStatus(t("reset.status"));
      });

      /******************************************************************
       * THEME TOGGLE
       * - body class 전환 + map style 전환
       * - setStyle 호출 시 style.load에서 레이어 재구성이 수행됨
       ******************************************************************/
      btnTheme.addEventListener("click", ()=>{
        if (currentTheme==="dark"){
          currentTheme="light";
          document.body.classList.add("light");
          syncThemeButtonLabel();

          showMapLoading(t("load.mapApplyLight"));
          map.setStyle("mapbox://styles/mapbox/light-v11");

          // 사용자에게 "즉시 반응"을 보여주기 위한 짧은 지연 후 hide
          setTimeout(()=>hideMapLoading(), 450);
        } else {
          currentTheme="dark";
          document.body.classList.remove("light");
          syncThemeButtonLabel();

          showMapLoading(t("load.mapApplyDark"));
          map.setStyle("mapbox://styles/mapbox/dark-v11");
          setTimeout(()=>hideMapLoading(), 450);
        }

        // 목록은 테마에 따라 색/배경이 달라지므로 재렌더
        if (currentTimelineIndex===-1) renderPhotoList(allPhotos);
        else applyTimelineFilter(currentTimelineIndex);
      });

      /******************************************************************
       * MODE SWITCH: Basic / Glow / Density
       ******************************************************************/
      function setActiveModeButton(){
        [modeBasicBtn, modeGlowBtn, modeDensityBtn].forEach(b=>b.classList.remove("active"));
        if (currentMapMode==="basic") modeBasicBtn.classList.add("active");
        if (currentMapMode==="glow") modeGlowBtn.classList.add("active");
        if (currentMapMode==="density") modeDensityBtn.classList.add("active");
      }
      modeBasicBtn.addEventListener("click", ()=>{ currentMapMode="basic"; applyMapMode(); });
      modeGlowBtn.addEventListener("click",  ()=>{ currentMapMode="glow";  applyMapMode(); });
      modeDensityBtn.addEventListener("click",()=>{ currentMapMode="density"; applyMapMode(); });

      function setLayerVisibility(id, vis) {
        if (map && map.getLayer(id)) map.setLayoutProperty(id, "visibility", vis);
      }

      /******************************************************************
       * applyMapMode
       * - 각 모드별로 보여줄 레이어/숨길 레이어를 분기
       * - density 모드에서는 region layers를 켜고 choropleth를 갱신
       ******************************************************************/
      function applyMapMode(){
        setActiveModeButton();

        const showDensityUI = (currentMapMode === "density");
        document.getElementById("region-controls").style.display = showDensityUI ? "block" : "none";
        document.getElementById("density-legend").style.display  = showDensityUI ? "block" : "none";

        if (!showDensityUI && densityPalettePop) densityPalettePop.style.display = "none";

        const hideDensityLayers = () => {
          ["sido", "sigungu"].forEach(lvl => {
            setLayerVisibility(`regions-${lvl}-fill`, "none");
            setLayerVisibility(`regions-${lvl}-outline`, "none");
            setLayerVisibility(`regions-${lvl}-label`, "none");
          });
        };

        if (currentMapMode === "basic") {
          setLayerVisibility("clusters", "visible");
          setLayerVisibility("cluster-count", "visible");
          setLayerVisibility("unclustered-thumb", "visible");
          setLayerVisibility("photos-glow", "none");
          setLayerVisibility("photos-core", "none");
          hideDensityLayers();
          setStatus(t("mode.statusBasic"));

        } else if (currentMapMode === "glow") {
          setLayerVisibility("clusters", "none");
          setLayerVisibility("cluster-count", "none");
          setLayerVisibility("unclustered-thumb", "none");
          setLayerVisibility("photos-glow", "visible");
          setLayerVisibility("photos-core", "visible");
          hideDensityLayers();
          setStatus(t("mode.statusGlow"));

        } else if (currentMapMode === "density") {
          setLayerVisibility("clusters", "none");
          setLayerVisibility("cluster-count", "none");
          setLayerVisibility("unclustered-thumb", "none");
          setLayerVisibility("photos-glow", "none");
          setLayerVisibility("photos-core", "none");

          setLevel(currentLevel);
          setStatus(t("mode.statusDensity"));
        }
      }

      /******************************************************************
       * REGION POPUP (DENSITY)
       * - region layer 클릭 시 해당 polygon 안의 사진 thumb 목록 팝업 출력
       ******************************************************************/
      const regionClickBound = { sido:false, sigungu:false };

      function escapeHtml(s){
        return String(s ?? "").replace(/[&<>"']/g, m => ({
          "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
        }[m]));
      }

      // 현재 필터(타임라인) 상태의 photo 목록을 "thumb url 포함" 형태로 반환
      function getCurrentPhotoObjects(){
        const src = (lastPhotos && lastPhotos.length > 0) ? lastPhotos : allPhotos;
        return src.map(p => ({
          ...p,
          thumb: thumbObjectUrlByPhotoId.get(p.id) || ""
        }));
      }

      // 팝업에서 썸네일 클릭 시, 해당 사진으로 이동 + 목록 하이라이트
      window.focusPhotoFromPopup = function(photoId, lon, lat){
        selectedPhotoId = photoId;
        try { highlightPhotoInList(photoId); } catch(e) {}
        if (map) map.flyTo({ center:[Number(lon), Number(lat)], zoom: 15, duration: 900 });
      };

      function showRegionPhotosPopup(level, regionFeature, lngLat){
        const photos = getCurrentPhotoObjects();

        // Turf로 point-in-polygon 검사: 간단하지만 O(N*M)이라 데이터 많아지면 최적화 필요
        const inside = photos.filter(p=>{
          if (p.lon == null || p.lat == null) return false;
          return turf.booleanPointInPolygon(turf.point([p.lon, p.lat]), regionFeature);
        });

        const title = escapeHtml(
          regionFeature.properties?.name
          ?? regionFeature.properties?.NAME_1
          ?? regionFeature.properties?.SIG_KOR_NM
          ?? regionFeature.properties?.CTP_KOR_NM
          ?? t("regionPopup.titleFallback")
        );

        const itemsHtml = inside.map(p=>{
          const img = p.thumb || "";
          const name = escapeHtml(p.name || "");
          return `
            <div style="width:72px">
              <img src="${img}" title="${name}"
                onclick="focusPhotoFromPopup('${p.id}', ${p.lon}, ${p.lat})"
                style="width:72px;height:72px;object-fit:cover;border-radius:10px;cursor:pointer;display:block;background:#111;border:1px solid rgba(255,255,255,.12)" />
            </div>
          `;
        }).join("");

        const html = `
          <div style="font-weight:700;margin-bottom:6px">${title}</div>
          <div style="font-size:12px;opacity:.85;margin-bottom:10px">${t("regionPopup.photoCount",{count:inside.length})}</div>
          ${inside.length === 0 ? `<div style="font-size:12px;opacity:.8">${t("regionPopup.none")}</div>` : `
            <div style="display:flex;flex-wrap:wrap;gap:8px;max-width:280px;max-height:220px;overflow:auto;padding-right:4px">
              ${itemsHtml}
            </div>
          `}
        `;

        new mapboxgl.Popup({ closeButton:true, maxWidth:"320px" })
          .setLngLat(lngLat)
          .setHTML(html)
          .addTo(map);
      }

      /******************************************************************
       * bindRegionClickHandlers
       * - density mode region fill/label 클릭 바인딩
       * - 중복 바인딩 방지(regionClickBound)
       ******************************************************************/
      function bindRegionClickHandlers(level){
        if (regionClickBound[level] || !map) return;

        ["sido","sigungu"].forEach(level=>{
          const fillId  = `regions-${level}-fill`;
          const labelId = `regions-${level}-label`;

          if (map.getLayer(fillId)) {
            map.on("click", fillId, (e)=>{
              if (currentMapMode !== "density") return;
              const f = e.features && e.features[0]; if (!f) return;
              showRegionPhotosPopup(level, f, e.lngLat);
            });
          }

          if (map.getLayer(labelId)) {
            map.on("click", labelId, (e)=>{
              if (currentMapMode !== "density") return;
              const clicked = e.features && e.features[0]; if (!clicked) return;

              // label은 별도 source라 polygon feature를 다시 찾아야 함
              const polys = map.queryRenderedFeatures(e.point, { layers: [fillId] });
              const poly = polys && polys[0];
              if (!poly) return;

              showRegionPhotosPopup(level, poly, e.lngLat);
            });
          }
        });

        regionClickBound[level] = true;
      }

      /******************************************************************
       * DENSITY LEGEND
       ******************************************************************/
      function updateLegend(maxCount){
        if (!legendScale || !legendRange) return;
        legendScale.innerHTML = "";
        for (let i=0; i<CHORO_COLORS.length; i++){
          const cell = document.createElement("div");
          cell.style.background = CHORO_COLORS[i];
          cell.style.height = "10px";
          cell.style.flex = "1";
          cell.style.display = "inline-block";
          legendScale.appendChild(cell);
        }
        legendRange.textContent = `0 ~ ${maxCount || 0}`;
      }

      function applyDensityPalette(key){
        currentDensityPaletteKey = key || "blue";
        CHORO_COLORS = (CHORO_PALETTES[currentDensityPaletteKey] || CHORO_PALETTES.blue).slice();

        // UI에서 active 상태 표시
        if (densityPalettePop) {
          densityPalettePop.querySelectorAll(".pop-opt").forEach(btn=>{
            btn.classList.toggle("active", btn.dataset.pal === currentDensityPaletteKey);
          });
        }

        updateLegend(maxCountGlobal);

        // density 모드면 즉시 재렌더
        if (currentMapMode === "density") {
          refreshChoroplethWithFilteredPoints(getCurrentPhotoPoints());
        }
      }

      // 현재 필터 상태의 point list(좌표만)
      function getCurrentPhotoPoints(){
        const src = (lastPhotos && lastPhotos.length > 0) ? lastPhotos : allPhotos;
        return src.map(p => ({ lng: p.lon, lat: p.lat }));
      }

      /******************************************************************
       * aggregateCounts
       * - 각 polygon(feature)에 대해 count=0 초기화
       * - point들을 순회하며 point-in-polygon으로 count 누적
       * - maxCount를 반환하여 choropleth 스케일 기준으로 사용
       *
       * 성능 주의:
       * - 현재 구현은 point마다 모든 feature를 순회(최악 O(N*M))
       * - 데이터가 커지면 bbox 인덱싱, spatial indexing(RTree) 고려
       ******************************************************************/
      function aggregateCounts(geojson, points){
        geojson.features.forEach((f, i) => {
          if (!f.properties) f.properties = {};
          f.properties.count = 0;
          if (f.id === undefined || f.id === null) f.id = i;
        });

        if (!points || points.length === 0) {
          return { geojson, maxCount: 0 };
        }

        for (const pt of points){
          const x = pt.lon ?? pt.lng;
          const y = pt.lat;
          if (x == null || y == null) continue;
          const p = turf.point([x, y]);

          for (const f of geojson.features) {
            if (f.geometry && (f.geometry.type === "Polygon" || f.geometry.type === "MultiPolygon")) {
              if (turf.booleanPointInPolygon(p, f)) {
                f.properties.count += 1;
                break;
              }
            }
          }
        }

        let maxCount = 0;
        for (const f of geojson.features) {
          if (f.properties.count > maxCount) maxCount = f.properties.count;
        }
        return { geojson, maxCount };
      }

      /******************************************************************
       * upsertChoropleth
       * - region geojson source + fill/outline/label 레이어를 생성 또는 갱신
       * - fill-color는 feature-state로 주입하여, 소스 전체를 매번 재작성하지 않아도 되게 설계
       ******************************************************************/
      function upsertChoropleth(level, aggregated, maxCount){
        const sourceId = `regions-${level}-src`;
        const fillId   = `regions-${level}-fill`;
        const lineId   = `regions-${level}-outline`;

        // source upsert
        if (map.getSource(sourceId)) map.getSource(sourceId).setData(aggregated);
        else map.addSource(sourceId, { type: "geojson", data: aggregated });

        // fill layer upsert
        if (!map.getLayer(fillId)) {
          map.addLayer({
            id: fillId,
            type: "fill",
            source: sourceId,
            paint: {
              "fill-color": ["coalesce", ["feature-state", "fill"], "rgba(0,0,0,0)"],
              "fill-opacity": 0.8,
              "fill-outline-color": "rgba(0,0,0,0)"
            },
            layout: { visibility: "visible" }
          }, "photos-core"); // 레이어 순서: photos-core 아래에 배치하려는 의도
        } else {
          map.setLayoutProperty(fillId, "visibility", "visible");
        }

        // outline layer upsert (테마에 따라 색 변경)
        const lineColor = (currentTheme === "dark") ? "#ffffff" : "#334155";
        if (!map.getLayer(lineId)) {
          map.addLayer({
            id: lineId,
            type: "line",
            source: sourceId,
            paint: {
              "line-color": lineColor,
              "line-width": ["interpolate", ["linear"], ["zoom"], 7, 0.4, 12, 1.2],
              "line-opacity": 0.3
            },
            layout: { visibility: "visible" }
          }, "photos-core");
        } else {
          map.setPaintProperty(lineId, "line-color", lineColor);
          map.setLayoutProperty(lineId, "visibility", "visible");
        }

        /******************************************************************
         * Labels: count>0인 region만 label 표시
         * - label은 polygon 자체가 아니라 pointOnFeature로 중앙 점 생성
         ******************************************************************/
        const labelSrcId = `regions-${level}-label-src`;
        const labelId    = `regions-${level}-label`;

        const labelFC = {
          type: "FeatureCollection",
          features: aggregated.features
            .filter(f => (f.properties?.count || 0) > 0)
            .map(f => ({
              type: "Feature",
              geometry: turf.pointOnFeature(f).geometry,
              properties: { count: f.properties.count || 0 }
            }))
        };

        if (map.getSource(labelSrcId)) map.getSource(labelSrcId).setData(labelFC);
        else map.addSource(labelSrcId, { type: "geojson", data: labelFC });

        if (!map.getLayer(labelId)) {
          map.addLayer({
            id: labelId,
            type: "symbol",
            source: labelSrcId,
            layout: {
              "text-field": ["to-string", ["get", "count"]],
              "text-size": ["interpolate", ["linear"], ["zoom"], 6, 10, 10, 14, 14, 18],
              "text-allow-overlap": true
            },
            paint: {
              "text-color": currentTheme === "dark" ? "#ffffff" : "#0f172a",
              "text-halo-color": currentTheme === "dark" ? "#000000" : "#ffffff",
              "text-halo-width": 1.2
            }
          }, "photos-core");
        } else {
          map.setLayoutProperty(labelId, "visibility", "visible");
        }

        // region 클릭 핸들러 연결
        bindRegionClickHandlers(level);

        /******************************************************************
         * Feature-state 색상 계산
         * - count=0은 거의 안 보이게 처리
         * - count>0은 maxCount 대비 ratio로 색상 단계 선택
         ******************************************************************/
        aggregated.features.forEach((f) => {
          const id = f.id;
          const count = f.properties.count || 0;

          let color;
          if (count === 0) {
            color = (currentTheme === "dark")
              ? "rgba(255, 255, 255, 0.03)"
              : "rgba(0, 0, 0, 0.03)";
          } else {
            const ratio = count / maxCount;
            const steps = CHORO_COLORS.length - 1;
            let cIdx = Math.ceil(ratio * steps);
            if (cIdx < 1) cIdx = 1;
            if (cIdx > steps) cIdx = steps;
            color = CHORO_COLORS[cIdx];
          }
          map.setFeatureState({ source: sourceId, id: id }, { fill: color });
        });

        updateLegend(maxCount);
      }

      /******************************************************************
       * clearChoroplethLayer
       * - 레벨 변경 시 기존 레벨 레이어/소스를 제거하여 중복 표시 방지
       ******************************************************************/
      function clearChoroplethLayer(level){
        const sourceId   = `regions-${level}-src`;
        const fillId     = `regions-${level}-fill`;
        const lineId     = `regions-${level}-outline`;
        const labelId    = `regions-${level}-label`;
        const labelSrcId = `regions-${level}-label-src`;

        if (map.getLayer(labelId)) map.removeLayer(labelId);
        if (map.getSource(labelSrcId)) map.removeSource(labelSrcId);

        if (map.getLayer(fillId)) map.removeLayer(fillId);
        if (map.getLayer(lineId)) map.removeLayer(lineId);
        if (map.getSource(sourceId)) map.removeSource(sourceId);
      }

      /******************************************************************
       * setLevel
       * - sido/sigungu 경계 GeoJSON을 필요 시 로딩
       * - 다른 레벨의 choropleth는 제거
       * - 현재 포인트(필터 반영) 기준으로 count 집계 → choropleth 반영
       ******************************************************************/
      async function setLevel(level){
        currentLevel = level;

        if (!boundaryCache[level]) {
          const url = level === "sido" ? SIDO_GEOJSON_URL : SIGUNGU_GEOJSON_URL;
          const res = await fetch(url);
          const gj = await res.json();
          gj.features.forEach((f,i)=>{ if (f.id==null) f.id = i; });
          boundaryCache[level] = gj;
        }

        const other = level === "sido" ? "sigungu" : "sido";
        clearChoroplethLayer(other);

        const base = JSON.parse(JSON.stringify(boundaryCache[level]));
        const { geojson, maxCount } = aggregateCounts(base, getCurrentPhotoPoints());
        maxCountGlobal = maxCount;
        upsertChoropleth(level, geojson, maxCount);
      }

      /******************************************************************
       * refreshChoroplethWithFilteredPoints
       * - 타임라인 필터/데이터 업데이트 후 density choropleth를 갱신
       ******************************************************************/
      function refreshChoroplethWithFilteredPoints(points){
        if (!map) return;
        const level = currentLevel;
        const cached = boundaryCache[level];
        if (!cached) return;

        const cloned = JSON.parse(JSON.stringify(cached));
        const { geojson, maxCount } = aggregateCounts(cloned, points);
        maxCountGlobal = maxCount;

        upsertChoropleth(level, geojson, maxCount);
      }

      // region level 라디오 변경 이벤트
      document.querySelectorAll('input[name="region-level"]').forEach((radio) => {
        radio.addEventListener("change", (e) => {
          currentLevel = e.target.value;
          if (currentMapMode === "density") setLevel(currentLevel);
        });
      });

      /******************************************************************
       * Density Palette Popup UI
       ******************************************************************/
      function openDensityPalettePop(){
        if (!densityPalettePop) return;
        densityPalettePop.style.display = "block";
        applyDensityPalette(currentDensityPaletteKey);
      }
      function closeDensityPalettePop(){
        if (!densityPalettePop) return;
        densityPalettePop.style.display = "none";
      }
      function toggleDensityPalettePop(){
        if (!densityPalettePop) return;
        const isOpen = densityPalettePop.style.display === "block";
        if (isOpen) closeDensityPalettePop();
        else openDensityPalettePop();
      }

      // legend 클릭 → 팔레트 팝 토글
      if (densityLegendEl) {
        densityLegendEl.addEventListener("click", (e)=>{
          if (currentMapMode !== "density") return;
          e.stopPropagation();
          toggleDensityPalettePop();
        });
      }

      // 팔레트 버튼 클릭 → 적용 후 닫기
      if (densityPalettePop) {
        densityPalettePop.addEventListener("click", (e)=>{
          e.stopPropagation();
          const btn = e.target.closest(".pop-opt");
          if (!btn) return;
          applyDensityPalette(btn.dataset.pal);
          closeDensityPalettePop();
        });
      }

      // 바깥 클릭 시 닫기
      document.addEventListener("click", ()=>{
        closeDensityPalettePop();
      });

      // 초기 팔레트 설정
      applyDensityPalette("blue");
    </script>
  </body>
</html>